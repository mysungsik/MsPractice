- 1. [FUNCTION.JS]       ================================================================================================================================

[1. 함수 파라미터에 기본값 추가하기]  
    function(userName = "user"){
        console.log(userName)}

    * [기본값이 있는 매개변수]는 [다른 모든 매개 변수 다음에 추가]하는 것이 중요합니다.

[2. 나머지연산자(rest parmeter)[...] 동적으로 파라미터를 추가할 수 있는 함수 만들기]
    function sumUp(...number){
        result = 0;
        for(const num of number){
            result =+ num
        }
        return result;
    }
    
    * [나머지연산자]는 [다른 모든 매개 변수 다음에 추가]하는 것이 중요합니다.

[3. 스프레드 연산자(spread parmeter)[...]를 통해 [배열으로 된 변수를, 하나하나씩의 값으로 만들기]]
    => 스프레드 연산자 : [값 만을 가져온다.]
        왜 그런일이 필요할까? : array, object는 변수에 저장할때 [주소]로 저장하기 때문에, 
            사실 배열이나 객체를 담은 변수를 불러오면 [값이 아닌 주소를 가져오는 것이다.]

[4. 함수도 [객체]이다.]
    function ms(){
        console.log("hi")
    }
    ms.id = "ms"
    console(ms.id)
    => 결국 [객체]이므로, [객체처럼 (.)을 써서 사용할수도, 키와 값을 추가할수도 있다.]

[5. "템플릿 리터럴" 을 사용한 [변수를 포함한 동적인 코드]]

[6. 기본값과 참조값]
    원시값 : 기본값으로서, 크기가 작은 boolean, number, string 등...
    참조값 : 큰 값들로, object, Array 등이 있다.
    * 참조값은 [주소로 저장된다.] 참조값의 변수는 [포인터일 뿐이다.]

    
[7. try catch 를 통해 [함수의 오류를 처리하고, 끊기지 않는 함수 만들기]]
    ==> express 의 경우, 오류를, status 로 알리고, 다른것을 render하여, 처리 할 수도 있다. [미들웨어를 통해]
    ==>> 하지만 그런 일 조차, [함수가 실행중 오류로 인해, 종료되고 넘어가는 것이다.]
    ==>>> [오류가 나더라도, 함수가 중지되지 않고, 끝가지 실행되어야 하는 함수를 만들때] [try,catch 를 사용한다.]

    사용 : [오류가 날 것으로 예상되는 곳에 사용]

- [2.Object.JS]       ================================================================================================================================

[1. new 란 무엇인가,  Date 는 왜 저렇게 쓰이는가, this는 무엇인가]

console.log(new Date().toISOString())

 -  1. Date()
        이름 : [생성자함수] 혹은 [생성자클래스]
        특징 : 파란색이다. 객체이다. [여러 객체들이 내장되어있다.]
        사용 : [이미 정의되어있는 객체(함수)로, 그냥 뽑아서 사용하면된다.]

-   2. new
        사용 : [새로운 object]를 [호출할때 사용]!!!
        
-   3. this
        사용 : 1. [빈 객체를 암시적으로 만들어냄]
               2. [클래스를 기반으로 한 객체를 대변함]    
                    ex) job 이라는 함수이자 객체 를 this 로 받아, this.title 등을 `템플릿 리터럴`에 사용가능 [2-2. 생성자함수만들기 - 함수추가] 에서 다룸
        
        ex) const ms = {}
            ms.age = 30
            ms.id = "msms"
            ==>> ms = { age:30 , id : "msms"} 가 되는것처럼

            this.name =;
            this.id = ;
            하면 [만들어진 객체에 키:값 쌍이 들어가는 형태이다.]

[2-1. 생성자함수 만들기 - 객체를 만드는  constructor]
    생성자함수란 : [함수는 함수인데, 객체를 만드는 함수이다.]

    만드는 이유 : [객체를 편하게 생성하기 위함이다]
    예시 : [사용자의 주소, 연봉, 직장 등을 포함한 객체를 여러개 생성하려면]

        const job1 = {
            job: ...
            salry : ...
        }
        const job2 = {
            job: ... 
            salary : ...
        }
        
        무한정 적어내야한다.
    =   [객체를 만드는 [생성자함수] 만든다면 , 편하게 [객체를 생성할 수 있다.]]

    사용 : class Job {
                constructor(Jobtitle,place,salary){
                    this.title = Jobtitle,
                    this.location = place
                    this.salary = salary
                }   
            }
            const job1 = new Job("hey","incheon",5000)
            console.log(job1)
        
    설명 :  1. 이름은 첫글자 대문자로
            2. constructor(){} 를 통해 자신만의 [객체]를 만듬
            3. 사용은 new Job()
            4. this : [클래스를 기반으로] [생성될 객체를 참조]한다.

    헷갈리는점 : 1. constructor(){} 는 안에, 객체를 넣을것이지만, = 기호를 사용한다.
                2. constructor(){} 안에는, 전체 객체를 받는 [this] 를 꼭 사용한다.
                

[2-2. 생성자함수 만들기 - 함수 추가]
-           : 생성자함수에 [함수를 추가해보자]

    생성:   class Job {
                constructor(Jobtitle,place,salary){
                    this.title = Jobtitle,
                    this.location = place
                    this.salary = salary
                }
                decribe(){
                    console.log(` ${this.title} ${this.location} ${this.salary}`)
                }
            }
    사용:
            const developer = new Job("developer", "NewYork",5000)
            const cook = new Job("cook","incheon",35000)

            developer.decribe();
            cook.decribe();

-   장점: [블루프린트(Job)] 하나에 [객체와 함수를 전부 담아], [그 객체를 포함하는 함수를 자유롭게 사용가능]


[3. 배열 비구조화]

    const hobbies = ["soccer", "baseball","football"]
    const [man, maan, maaan] = hobbies
    console.log(man)
    console.log(maan)
    console.log(maaan)

- 배열을 쪼개서, 각각의 변수에 각 값을 넣음

[4. 객체 비구조화]
    const hobbiess = {a : "soccer", b: "baseball", c: "football"}
    const {a} = hobbiess

    [객체 비구조화는, 변수 이름이, 객체의 속성중 키 값을 그대로 따라오게 되어있는데]
    [만약 변수이름을 수동으로 바꾸고 싶다면]

    const {b :myjob, c:mysecond}  = hobbiess
    console.log(myjob)
    console.log(mysecond)
    - hobbiess 중, [b에 해당하는 값을 꺼내],[myjob이라는 변수에 저장하겠다] 라는 뜻이된다. 


-   [3.Async]       ================================================================================================================================

[1. sync(동기식) 와 async(비동기식)]

sync : 파일이 읽혀지고 실행될때까지, 코드는 멈추고, 읽는것을 우선시하여, 전부 다 읽혀야 코드가 넘어감
async : 파일이 읽혀지고 실행될때까지, 다음 줄의 코드들은 계속해서 작동함

[차이점]
조건1 [파일을 읽는 도중, 아직 파일이 읽히지 않은채, [파일과 연관된 다음줄의 코드가 먼저실행] ==> 오류발생 ==> 동기식으로 파일부터 전부 읽히고, 넘어가야함]
조건2 [파일을 읽는 도중 다음 코드 줄을 읽어도, [파일과 다음코드줄이 전혀 관계가 없음] ==>> 비동기식으로 해도 전혀 상관 X]

[작동조건]
sync : [알아서 retrun 되므로] [변수에 저장하여 사용] ****
async : [스스로 return 되지 않음!] *****


-  [비동기식의 사용] :
        비동기식의 콜백함수는 [2가지의 파라미터를 가진다.]
             - [error, 읽은 파일을 저장할 변수이름]

        function readFileData(){
            let fileData;

            fs.readFile("data.txt", function(error, fileData){
                if(error === true){
                    ...
                }
                console.log("file parsing done!")
                console.log(fileData.toString())
            })
        }
        ==>> [error] 라는 파라미터는 [오류가 발생했을때 값을 가지고]
            [변수 fileData] 는, "data.txt" 읽기가 성공하면 fileData에 데이터를 저장한다.
-       ==>> [중요한점은]
            [비동기식] [콜백함수]의 내부에서 사용된 [fileData]는 [readFile() 이라는 함수 내부에서만 사용가능하다]
            그러므로, fileData 를 [읽어서 사용할 것들은 전부 readFile의 콜백함수 내부에 전부 몰아넣어 사용해야한다.]
-       ==>> [그래서 콜백함수 내부에 console.log(fileData.toString()) 가 들어가있는 것이다.]

* 중요한것 : callback 함수라는 단어의 이해

[2. 비동기작업의 콜백함수의 지옥에서 탈출하기] 
                                ==>> promise , .then() , .catch(function(error){})

    : 수많은 readFile, dataBase의 접근 등으로 [우리는 수많은 콜백함수 안의 콜백함수 안의 콜백함수를 만나게된다.]
    : 코드는 읽기 어려워지고, 복잡해서지고, 오류가 날 확률리 높아진다.

-   [콜백함수지옥]
    fs.readFile("data.txt", function(error, fileData){
        if(error === true){
            ...
        }
        asd.function(asd, function(asd,fgdfh){
            asd.function(asd, function(sdf,sdfd){
                ...
            })
        })
    })
    [코드가 복잡해지고, 읽기 어려워지는 이 콜백함수를 탈출하기 위해] [깔끔하게 정리되는 promise 를 사용할것]

-   [프로미스를 사용한, 비동기식 사용]

    const fs = require(fs/promise)

    function readFilesToPromise(){
        let fileData
        fs.readFile("3.AsyncData.txt").then(function(fileData){
            console.log(fileData.toString())
        }).then(function(){
            ...
        }).then(function(){
            ...
        })
    }

    ===>> [promise] 를 통해서, [콜백함수 없이 [구조화되도록] 처리하도록 해본다.]

    [완벽한 장점]
        : 코드를 구조화하기 매우 좋다. [가동성이 매우 좋아진다.]
         Promise chain을 통해, 깔끔하고 보기좋은 코드를 만들 수 있다.

    [차이점]
    : [error 처리] .then(function(fileData)) 대신에

        .catch(function(error){
        })
        로 에러처리


[3. async 와 await 를 사용한, 동기식처럼 보이는 비동기식 처리]

-    [ async , await  :  프로미스 사용시 만 사용가능한 [마치 동기식으로 보이게 하는 비동기식 작용법] ]

    async function(){
        let fileData;

        fileData = await fs.readFile("data.txt")
    }

    [비동기식 이지만, 마치 동기식처럼 보이고, 파일에 저장하여 쓰는것이 가능해진다]  
-   [async 와 await 를 통해서!!!]


[결론]

-   [1. 동기식의 사용]

    const fs = require("fs")

    function(){
        const fileData;
        try{
            fileData = fs.readFileSync("data.txt")
        }
        catch{
            console.log("you got a error")
        }
    }


-   [2. 비동기식의 사용]  - 콜백함수*

    const fs = require("fs")

    function(){
        const fileData;
        fs.readFile("data.txt", function(error, fileData){
            if(error === true){
                console.log("you got a error")
            }
            console.log(fileData.toString())
        })
    }

-   [3. 비동기식의 사용] - promise , then , catch

    const  fs = require("fs/promises")

    function(){
        const fileData;
        fs.readFile("data.txt").then(function(fileData)){
            console.log(fileData.toString())
        }.then(function(...){
            ...
        }).then(function(){
            ...
        })catch(error){
            console.log(error)
        }
    }


-   [4. 비동기식의 사용]  - promise , async, await 를 사용한 [동기식 처럼 보이는 비동기식 사용]

    const fs = require("fs/promises")

    async function(){
        const fileData;
        try{
            fileData = await fs.readFile("data.txt")
        }catch{
            console.log(error)
        }   
       
        console.log(fileData.toString())
    }

-   [5. 동기식 비동기식 차이 최종결론]
        [동기식] 1. try catch 를 통한 오류 처리
                2. file 을 변수에 받아서 쓸 수있음
                3. require("fs")
                4. 파일 읽는 도중, 코드 멈춤
                5. 항상 자동으로 값을 return 함

        [비동기식]  1. error 파라미터를 사용해, 오류 처리
                   2. file을 변수에 받아서 쓸 수 없음
                   3. promise 사용시 [require("fs/promises")]
                   4. 파일 읽는 도중에도 코드는 계속 흘러감
                   5. 자동으로 값을 return 하지 않음!