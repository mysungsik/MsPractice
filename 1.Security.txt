[1-1. CSRF Attacks]
[1-2. CSRF 방어 = SameSite Cookies]
[1-3. CSRF 방어 = CSRF 토큰]
[2-1. XSS Attacks]
[2-2. XSS Attacks 방어 : Escape, Sanitize]
[3-1. SQL Injection Attacks]
[3-2 SQL Injection Attacks 방어 : 이스케이프하여 사용하기]


[추가]
[1. 필터를 사용해, 원하는 값만 템플릿에 표시하기]


================================================================================================================================================================================================================


0. Web Security
    : 웹사이트의 취약점을 알아보고 막아보자.

[1-1. CSRF Attacks]
    : Cross Site Request Forgery
    [비슷한페이지를 만들어, 링크를 보내, 유저들을 낚아 유저들의 세션을 가져와, 본 사이트에 집어넣고, 로그인함] 

    클라이언트는 같아보이는 페이지에서 돈을 보내지만,
    사실은 이미 정해져있는 값에 의해, 다른곳으로 돈이 전달되고
    해커는 돈을 보내면 정상적인 페이지로 action을 하여 더 헷갈리게함.

[1-2. CSRF 방어 = SameSite Cookies]
    : 같은 사이트 내에서만 쿠키가 전송되도록 하는 [브라우저의 장치] ex) crome 은 되지만, safari는 지원하지않음
    : Fishing 링크가 비슷한 이름으로, 비슷한 사이트를 만들어 사용자를 낚지만
        URL이 다른, 다른 사이트 일 경우, 쿠키가 전송되지 않게 만드는것.

    app.use(session({
        ...

        Cookies : {
            maxAge : ...
            SameSite : "lax"
        }

    }))

    ==>> 크롬은 자동지원하지만, 자동지원하지 않는 브라우저를 위해, sesison을 만들때, cookies 에 넣어주는것.

[1-3. CSRF 방어 = CSRF 토큰]
    CSRF토큰 :  서버사이드에서 생긴 한번의 요청에만 살아있는 토큰
                세션을 템플릿에 주입할때, csrf토큰을 주입
                진입시, 브라우저에서 서버로 들어온 요청의 CSRF토큰을 확인
                만약 CSRF토큰이 없다면 요청 거절
                ==>> [진화된 쿠키]

    1) express csrf 검색 [csrf토큰 생성 패키지 찾기]
    2) csurf 패키지 설치
    3) 미들웨어에 추가
    4) 사용할 라우트에 추가
    5) 사용할 라우트에서 렌더할때, 내보냄
    6) 템플릿에서 모든 [폼에 대하여, 히든 인풋의 value로 집어넣음, 이름은 반드시 _csrf 로]

    <app>
        const csrf = require("csurf")

        app.use(csrf());

    <route>

        route.get("/", function(){
            ...
            const csrfToken = req.csrfToken();
            res.render("/", {csrfToken:csrfToken})
        })

    <templete>

        <form>
            <input type = "hidden" value = "<%= csrfToken %>" name = "_csrf">                                                                                    "
            ...
        </form>

[결론]
    [전체에서, CSRF 토큰을 생성하는 패키지를 설치하고]
    [라우트에서 CSRF 토큰을 템플릿에 주입하며]
    [템플릿에서는 페이지를 요청할때, CSRF 토큰을 출입문키처럼 제시한다.]
    [전체에서, 미들웨어를 통해 CSRF 토큰이 없다면, 출입을 시켜주지 않는다.]


    
[2-1. XSS Attacks]
    :  Cross site Scripting
    [ 유저가 악성JavaScript 코드를] [입력창에 쓰면] [그 입력창을 DataBase에 넣어 출력하는 시스템이 있을경우]
        [DataBase에서 악성JavaScript가 실행되어 DataBase에 커다란 데미지를 줄 수있다. ]

    ex) 유저가 마음대로 쓸 수 있는 글(ex form text)이 DataBase에 자동으로 저장되는 것을 악용하여,
        <Script> alert("warning") </Script> 등으로 페이지를 바꿔놓을 수도, Ajax 요쳥으로 유저의 세션을 받아 올 수도 있다.
        유저가 마음대로 주무를 수 있다는 커다란 문제가 발생한다.

    [기본 배경]  

        1) 이스케이프
            : escape 란, [컨텐츠의 HTML이 원시텍스트로 변환되어], 브라우저에서 구문분석하지 못하고, 화면에 일반텍스트로 변환되어 보여지는 것

        2) 유저의 입력을 [사용하거나 저장하기전] [삭제하기] (Sanitize)
            : 사용자 입력창에 입력된 값을 [사용하거나 데이터베이스에 저장하기 전에]
                우선 살펴보고, 불필요한 값들을 삭제 후에 처리 [ ex) <Script> 라고 적은 텍스트들은 삭제시키고 저장]

[2-2. XSS Attacks 방어 : Escape, Sanitize]

    1. 이스케이프 ***
        : 컨텐츠의 값을 [원시 텍스트로!]

        계속해서 사용하던 <%= %> 가 바로 [이스케이프 태그]이다.
        반대로, <%- %> 를 사용했을 때에는 [HTML에서 분석을 하는 코드로 변한다.]
        
        EX) <%= comment.title %>        ==>> 화면에 comment.title 에 대해, [텍스트값] 으로 화면에 표시
            <%- comment.title %>        ==>> 화면에 comment.title 에 대해, [HTML구문으로 분석하여] 화면에 표시

    2. 유저의 입력을 [사용하거나 저장하기전] [삭제하기] (Sanitize)
        : 유저가 입력한 값을 [반드시 HTML 구문으로 분석해서 표시해주어야 하는 경우] 사용가능하다. 예시로는 [스팀게임의 댓글창 같이]

        1) express sanitize user input 검색
            or express xss 검색

        2) xss 설치

        3) [사용할곳] = '라우트' 에 require 하고, [필요한 곳] = [데이터베이스에 저장할 값을 받아오는 라우트]안의 [ 데이터베이스에 저장할 값] 을 코드로 감싸준다.


        <user input>

            <Script> alert("warning") </Script>

        <routes>
-           const xss = require("xss")
            ...

            route.post("/", function(){

                const comment = {
-                   text : xss(req.body.text)
                }
                await db.getDb().collection("database").insertOne(comment)
            })

        ==>> 안에있는 <script> 태그가 사용되지 않고, 단순히 [텍스트로서 <script> 라고 저장된다. ]

[3-1 SQL Injection Attacks]
    :  사용자 입력창에, SQL 구문을 적음으로써, 데이터베이스를 공격한다.

ex) 
    router.get('/discussion', async function (req, res) {

    let filter = '';
  
    if (req.query.author) {
      filter = `WHERE author = "${req.query.author}"`;}
    const query = `SELECT * FROM comments ${filter}`;
    ...
    const [comments] = await db.query(query);
    }
    

    에서 [사용자 입력창에] "; DROP TABLE comments; "   를 집어넣으면,
-   데이터베이스의 comments 테이블이 삭제되는  결과를 야기한다.


[3-2 SQL Injection Attacks 방어 : 이스케이프하여 사용하기 + multipleStatements 기본값 사용하기]
    : 이미 이스케이프를 사용한 SQL문을 사용해보았다. 바로 ? 이다.

    router.get('/discussion', async function (req, res) {

        let filter = '';
      
        if (req.query.author) {
          filter = `WHERE author = ?`;}
        const query = `SELECT * FROM comments ${filter}`;
        ...
        const [comments] = await db.query(query, [req.query.author]);
        }

    ==>> ? (자리선택자) 를 활용한 코드로 변경한다.
-   자리선택자 ? 는 이미 [이스케이프] 처리된 코드이다.

    <database> 에서
-   multipleStatements : 여러개의 쿼리를 동시에 사용가능하도록 하는 코드
-   를 true로 사용하지 말고, 기본값인 false로 사용한다.

        const pool = mysql.createPool({
            host: '127.0.0.1',
            database: 'security',
            user: 'root',
            password: 'pw',
-           multipleStatements: true     ==>> 쓰지않거나, false 로 적기
        })
    ==>> 여러개의 쿼리문을 동시에 집어넣게만들어, 해킹하는 유저가 원하는 쿼리문을 사용하지 못하게 막는다.

[결론]

1. 절대로 유저인풋을 신뢰하지말것.
2. 반드시, 이스케이프 처리된 값만을 저장하고, 이스케이프 된값만을 사용해야함.
3. 불가피한 경우, 타사패키지를 이용해 처리할것. 
4. 모든 get 라우트에는 CSRF 공격에 관련하여,  csurf 를 사용해 CSRF 토큰을 생성할것.

[추가]

[1. 필터를 사용해, 원하는 값만 템플릿에 표시하기]

    [1. 템플릿에 코드 ]

        <form action = "", method = "">
            input type = "search" name = "name"
            <button> </button>
        </form>
            
        ==>> query 로, domain?name=[search태그에 입력한 값이 value가 됌!!]


    [2.  라우트에 동적 렌더]

        router.get('/discussion', async function (req, res) {
        let filter = '';
      
        if (req.query.name) {
          filter = `WHERE author = "${req.query.name}"`; 
        }
      
        const query = `SELECT * FROM comments ${filter}`;
      
        console.log(query);
      
        const [comments] = await db.query(query);
      
        res.render('discussion', { comments: comments });
      });
