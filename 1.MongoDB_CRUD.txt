===========================================================================================================================
[INDEX]

[0. mySQL과 가장 큰 차이]
[1. 데이터의 저장 - insertOne({})]
[2. 데이터의 읽기  - find() ] 
[3. 데이터의 업데이트 - updateOne({}) , updateMany({})]
[4. 데이터의 삭제 - deleteOne({}) , deleteMany({})] 


===========================================================================================================================


[0. mySQL과 가장 큰 차이]
    : [사전작업으로] [데이터를 저장할 공간을 분할하여 만들거나]
        [구조를 정리하여 미리 구성해 놓을 필요가 없음]


[1. 데이터의 저장 - insertOne({})]

    1.데이터베이스를 생성한다.
        : [use 데이터베이스이름]
        
        ex) use ratingportal

        * 만들어도, 데이터베이스에 값이 없다면 [전환만 되고, 실제로 만들어지지 않는다. 값을 넣자]


    2. 데이터를 삽입한다. - insertOne({}) , insertMany({})
        : [ db.컬렉션이름.insertOne({키:"밸류"}) ]

        ex) db.restaurants.insertOne({ name:"ms"})
        ex2) db.restaurants.insertOne({ name:"ms" , id : "msid"})
        ex3) db.restaurants.insertOne({ name:"ms" , id : "msid" , 
                address : {street: "street number5" , street Number : "233b"}})

        ==>> [데이터베이스, 컬렉션, 폴더{키:밸류} 순으로 상하관계가 분류되며]
                [밸류 안을 한번 더 나눌 수도 있다. [예시로 address 처럼]]
                ==>> "중첩된 문서" 라고 부른다.
-       명령어 소문자 대문자 구분 잘할것

[2. 데이터의 읽기  - find() ] 
    1. 데이터를 전부 찾기
        : [ db.컬렉션이름.find() ]

            ex) db.restaurants.find()

    2. 데이터를 필터하여 찾기

-       1) 찾고싶은 [조건을 만족하는] 폴더 찾기

        : [ db.컬렉션이름.find({ 조건 }) ]

            ex) db.restaurants.find({ name: "ms"})

        ==> name 이 ms인 [폴더]안의 값이 전부 나온다.

            db.restaurants.insertOne({ name:"ms" , id : "msid" , 
            address : {street: "street number5" , street Number : "233b"}})

            db.restaurants.insertOne({ name:"js" , id : "jsid" , 
            address : {street: "found street" , street Number : "13s"}})

            라고 저장했다면
        ==> 위에 name, id, address 까지 있는 한 폴더 전체가 나온다.

-       2) 오로지 [id 값만] OR [name 값만] 등의 [특정 데이터만 읽기]
        :  [  db.컬렉션이름.find( {} , {키:1, 키:0})  ]

            ex) db.restaurants.find( {} , {name:1, _id:0}) 

            ==> 첫번째 파라미터는 값을 가져오는 파라미터이고
                두번째 파라미터는 name 만 뽑아서 가져오겠다는 {name:1} 구문이다.
                    추가적으로  id 값은 가져오지 않겠다는 {_id:0} 구문이다.
                    

            ==> id만 뽑고싶다면 두번째 파라미터에 {_id:1} 을 쓰면 된다.
                * id 값은 원래 [_id] 가 풀네임이다.

-       3) 오로지 [일치하는 단 하나의 폴더만 가져오기]
        : [ db.컬렉션이름.findOne({조건})]

        ex) db.restaurants.find({ name: "ms"})

        ex2) db.reviews.find({rating: {$gt:4}})
            : rating 이 4 이상인 리뷰만 불러온다.

        ==> 데이터를 적은 사람은 알지라도, 컴퓨터는 알지 못한다.
            저 이름을 가지고 있는 폴더가 여러개인지 하나인지
        ==> fineOne 으로 단 하나만 가져오도록 명시한다.

            [비교문]
            * gt(greater than), lt(lower than), gte(greater than equal), lte(lower than equal)


[3. 데이터의 업데이트 - updateOne({}) , updateMany({})]

-   1. 일반적인 데이터의 업데이트
    :       [ db.컬렉션이름.updateOne( {조건} , { $set : {바꿀키:밸류}} ) ]

    ex) db.restaurants.updateOne({_id:ObjectId("630f039fc75c67a63e8479ea")}, { $set: {name:"pizzaHouse"}})

        * _id 값은 [ ObjectId("id값") ] 까지 전부 가져와야한다.

-   2. 중첩된 문서의 데이터 업데이트

    ex) db.restaurants.updateOne({_id:ObjectId("630f039fc75c67a63e8479ea")}, { $set: {"address.street":"pizzaHouse"}})

        ==>> [중첩된 문서의 데이터를 선택할 때에는]
            [ ""를 통해서, 중첩된곳까지 경로를 잡아준다. ]
        ==>> 일반적인것과 차이점
                [경로지정에 있어 ("")과 (.) 을 사용하여 지정한다.]


[4. 데이터의 삭제 - deleteOne({}), deleteMany({}) ] 
    [ db.컬렉션.deleteOne({조건})]

    ex. db.restaurants.deleteOne({ _id:ObjectId("630f039fc75c67a63e8479ea") })

===========================================================================================================================
[명령]

1. cls  
    : 클린

2. show dbs
    : 데이터베이스 확인

3. 위화살표
    : 썼던 데이터 복사
4. 마우스 우클릭
    : 글자복사

5. show collections
    : 콜렉션 보기