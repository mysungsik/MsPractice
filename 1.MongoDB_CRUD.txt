===========================================================================================================================
[INDEX]

[0. mySQL과 가장 큰 차이]
[1. 데이터의 저장 - insertOne({})]
[2. 데이터의 읽기  - find() ] 
    1) [조건을 만족하는] 폴더 읽기  -find ({name:"ms"})
    2) [특정 데이터만 읽기] , [특정 데이터만 빼고 읽기] - find({},{ 키:1})  or {키:0}
    3) [일치하는 단 하나의 폴더만 가져오기] -findOne()
    4) [특정 데이터만 find하는 이유] ********

[3. 데이터의 업데이트 - updateOne({}) , updateMany({})]
[4. 데이터의 삭제 - deleteOne({}) , deleteMany({})] 


===========================================================================================================================


[0. mySQL과 가장 큰 차이]
    1) [사전작업으로] [데이터를 저장할 공간을 분할하여 만들거나]
        [구조를 정리하여 미리 구성해 놓을 필요가 없음]

    2) [유니크한 ID가 자동으로 생성됨]


[1. 데이터의 저장 - insertOne({})]

    1.데이터베이스를 생성한다.
        : [use 데이터베이스이름]
        
        ex) use ratingportal

        * 만들어도, 데이터베이스에 값이 없다면 [전환만 되고, 실제로 만들어지지 않는다. 값을 넣자]


    2. 데이터를 삽입한다. - insertOne({}) , insertMany({})
        : [ db.컬렉션이름.insertOne({키:"밸류"}) ]

        ex) db.restaurants.insertOne({ name:"ms"})
        ex2) db.restaurants.insertOne({ name:"ms" , id : "msid"})
        ex3) db.restaurants.insertOne({ name:"ms" , id : "msid" , 
                address : {street: "street number5" , street Number : "233b"}})

        ==>> [데이터베이스, 컬렉션, 폴더{키:밸류} 순으로 상하관계가 분류되며]
                [밸류 안을 한번 더 나눌 수도 있다. [예시로 address 처럼]]
                ==>> "중첩된 문서" 라고 부른다.
-       명령어 소문자 대문자 구분 잘할것

[2. 데이터의 읽기  - find() ] 
    1. 데이터를 전부 찾기
        : [ db.컬렉션이름.find() ]

            ex) db.restaurants.find()

    2. 데이터를 필터하여 찾기

-       1) 찾고싶은 [조건을 만족하는] 폴더 찾기

        : [ db.컬렉션이름.find({ 조건 }) ]

            ex) db.restaurants.find({ name: "ms"})

        ==> name 이 ms인 [폴더]안의 값이 전부 나온다.

            db.restaurants.insertOne({ name:"ms" , id : "msid" , 
            address : {street: "street number5" , street Number : "233b"}})

            db.restaurants.insertOne({ name:"js" , id : "jsid" , 
            address : {street: "found street" , street Number : "13s"}})

            라고 저장했다면
        ==> 위에 name, id, address 까지 있는 한 폴더 전체가 나온다.

-       2) 오로지 [id 값만] OR [name 값만] 등의 [특정 데이터만 읽기] , [특정 데이터만 빼고 읽기]
        :  [  db.컬렉션이름.find( {조건} , {키:1})  ]

            ex) db.restaurants.find( {} , {name:1}) 
            ex2) db.restaurants.find( {} , {name:1, "address.street" : 1}) 

            ex3) db.restaurants.find( {} , {name:0}) 

            ==> 첫번째 파라미터는 [조건을 선택하는]
                두번째 파라미터는 name 만 뽑아서 가져오겠다는 {name:1} 구문이다.

-           ==> [표시하고 싶은 값만  [키:1] 을 사용하면 나머지는 자동으로 0 로 변하여, 표시되지 않는다.]
                [뽑고 싶은 특정 값만 1 로 표시하자] *************
                [ 단, id 는 자동으로 가져와진다.]
-           ==> [뺄 값만 [키:0] 을 사용하면 그 키 값만을 제외한 전부가 표시된다.]

-           ==> 중첩된 객체의 표현은  [""] 을 사용하여 표시하는 것을 잊지 말자



-       3) 오로지 [일치하는 단 하나의 폴더만 가져오기]
        : [ db.컬렉션이름.findOne({조건})]

        ex) db.restaurants.find({ name: "ms"})

        ex2) db.reviews.find({rating: {$gt:4}})
            : rating 이 4 이상인 리뷰만 불러온다.

        ==> 데이터를 적은 사람은 알지라도, 컴퓨터는 알지 못한다.
            저 이름을 가지고 있는 폴더가 여러개인지 하나인지
        ==> fineOne 으로 단 하나만 가져오도록 명시한다.

            [비교문]
            * gt(greater than), lt(lower than), gte(greater than equal), lte(lower than equal)


-       4) [특정 데이터만 find하는 이유]
            : 데이터베이스가 무거워지면, find() 로 전부 가져올 경우, [매우 많은 시간과 데이터 소모가 필요하다!]
                즉, 필요한 것만 따로 빼와야, 서버에 무리가 없다.


[3. 데이터의 업데이트 - updateOne({}) , updateMany({})]

-   1. 일반적인 데이터의 업데이트
    :       [ db.컬렉션이름.updateOne( {조건} , { $set : {바꿀키:밸류}} ) ]

    ex) db.restaurants.updateOne({_id:ObjectId("630f039fc75c67a63e8479ea")}, { $set: {name:"pizzaHouse"}})

        * _id 값은 [ ObjectId("id값") ] 까지 전부 가져와야한다.

-   2. 중첩된 문서의 데이터 업데이트

    ex) db.restaurants.updateOne({_id:ObjectId("630f039fc75c67a63e8479ea")}, { $set: {"address.street":"pizzaHouse"}})

        ==>> [중첩된 문서의 데이터를 선택할 때에는]
            [ ""를 통해서, 중첩된곳까지 경로를 잡아준다. ]
        ==>> 일반적인것과 차이점
                [경로지정에 있어 ("")과 (.) 을 사용하여 지정한다.]


[4. 데이터의 삭제 - deleteOne({}), deleteMany({}) ] 
    [ db.컬렉션.deleteOne({조건})]

    ex. db.restaurants.deleteOne({ _id:ObjectId("630f039fc75c67a63e8479ea") })

