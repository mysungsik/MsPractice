[1. http 패키지 불러오기]  
[2. sever 만들기]
[3. sever에 수신대기 포트 만들기]
[4. 요청과, 응답 함수를 만들어서 서버에 집어넣기]
[5. statusCode, end()]
[6. request 와 response]
[7. new Date().toISOString()]
[8. [node.JS] 그리고 [타사패키지 Express.js]]
[9. node express의 사용]
[10. 받아온 데이터를 다시 자바스크립트 코드로 변환하기] [use 를 사용하여!] + [미들웨어 함수]
[11. 파일에 접근하기 위한, 내장패키키지와 사용]
[12. HTML 파일과 node.js[서버] 사이의 연결]
[12-1. CSS, javaScript 같은 정적파일과 nodejs 연결!]
[13. res.send() 의 오류(새로고침시, 양식을 다시제출하는)를 방지하는,  res.redirect()]
[14. 템플릿과, 템플릿 엔진의 사용 ejs  [1단계 - 세팅]]
[14-1. 템플릿과, 템플릿 엔진의 사용 ejs  [2단계 - 사용 ,장점]]
[15. 동적 라우트를 연결]








[1. http 패키지 불러오기]  
const http = require(http)      // 물론 변수이름은 마음대로 

        HTTP PAKEAGE 둘러보기 ==>> https://nodejs.org/dist/latest-v18.x/docs/api/http.html
        [노드JS에서 제공하는] 유틸리티 [메서드와 프로퍼티]로 가득찬 [객체]가 반환된다.

[2. sever 만들기]
const sever = http.createServer()

[3. sever에 수신대기 포트 만들기]
server.listen(3000)         // 3000은 마음대로 입력한 [포트번호]이다.
                            // [여기까지 입력하면, 포트3000에 대한 요청을 수집하라 라는 코드이다.]

[4. 요청과, 응답 함수를 만들어서 서버에 집어넣기]

    - 앞선 2번의 서버만드는 코드에 추가

    const http = require(http) 

    function handleRequest(request, response){
        response.statusCode = 200;
        response.end("HTML태그 입력")
    }
    const sever = http.createServer( handleRequest )

    server.listen(3000)

    - createServer() 의 첫번째 파라미터로 [requestListener] 를 요구하므로, 집어넣는 것이다.
    - 또한, 만들어진 서버[포트번호 3000]에 요청이 들어올때마다, handleRequest 함수가 실행될것이다.

    [statusCode] 는 브라우저에게 [요청이 성공했는지에 대한 여부를 알리는 방법이다.]
    https://developer.mozilla.org/ko/docs/Web/HTTP/Status
    [200] 은 OK 를 나타내는 코드이다.

[5. statusCode, end()]

    1) statusCode
        : [브라우저]에게 [요청의 성공여부를 알려주는 코드]
    2) end()
        : 요청에 성공했다면, [응답준비를 마치고, 응답에 대한 것을 보낼 수 있다.]
        : [기본적으로 HTML태그를 보내보자.]


[6. request 와 response]        ****************************************************************

    1) request : [브라우저에서 서버로 보내는 요청들 중 하나]
                대표적으로 [request.url] 으로 포트 뒤의 URL 주소를 받아온다.
    2) response : [ 서버에서 브라우저로 보내는 응답 ]
                대표적으로 response.statusCode = ""
                          response.end()

[7. new Date().toISOString()]

    new Date() ==> 날짜 객체를 생성
    toISOString() ==> 문자열로 변환 함수

[8. [node.JS] 그리고 [타사패키지 Express.js]]

    nodeJS  : javaScript 의 언어를 사용하는 [브라우저 외부에 있는 javaScript], [서버에 적합한 프로그래밍 언어이다]
    nodeJS의 한계   : 많은 양의 코드를 적어야하고, 복잡하게 사용해야하는 기능들이 많다. [그래서 타사패키지를 사용할것이다.]
    타사패키지 설치 : npm init, npm install 패키지이름      을 통해 설치한다.
    Express.js 의 장점  : 짧고 간결한 코드, 다양하고 편리한 기능
    Express.js 의 사용 

[9. node express의 사용]
[ 파일을 주는 get, 파일을 받는 post ]
[ 파일을 주는 res, 파일을 받는 req ]
************************* [   get("", function(req,res){})   ] , [   post("", function(req,res){})  ]   ] **************************************

    1) get("", function(req,res){})
        :nodeJS 의 request와 response 를 합친 형태 중, *** [보내는 형태] ***

        get("/jsjs",  function(req, res){
            res.send("<h1> hi </h1>")
        })

        ==>> localhost:3000/jsjs 에 접근했다면, [응답하라(res)] = "<h1> hi </h1>" 을 적음으로써!



    2) post("", function(req,res){})
        :nodeJS 의 request와 response 를 합친 형태 중, *** [받는 형태] ***

        post("/msms", function(req,res){
            const userName = req.body.username;
            res.send("<h1> hi </h1>")
        })

        ==>> localhost:3000/msms 에 접근했다면, 

            req.body.username  ==>> [받아라(req)], [username] 이라는 [HTML의 name]을 [가진 요소의 데이터]를
        -   req.body   ==>> [form에서 나온 데이터 [전부]!]
        -   req.body.username ==> [forem에서 나온 데이터중, username이라는 name 을 가진 데이터만]

            [응답하라(res)], "<h1> hi </h1>" 라고 나타냄으로써!

    - 파일을 줄것이면 애초에 [get] 으로 접근하고.
    - 파일을 받을 것이면 애초에 [post] 로 접근한다.
    - [POST] 로 접근한 이유는 <form aciton="url 뒤의 주소" method = "POST"> 로 method를 post로 설정했기 때문이다.


    - 장점 = 간단하다, 사용방도가 많다, 
    -       statusCode 가 기본으로 200 으로 되어있어서 쓸 필요가 없다.

[10. 받아온 데이터를 다시 자바스크립트 코드로 변환하기] [use 를 사용하여!] + [미들웨어 함수]
    : 폼 양식을 통해, [브라우저에서 서버로] [데이터를 보냈다.]
        [그럼에도 불구하고, 데이터는 [자바스크립트코드가 아닌] [그저 데이터의 일부일뿐]]
        [ 그러므로, 자바스크립트에서 읽을 수 있도록 구문 분석을 해야한다.]

    const express = require("express")
    let app = express()

    app.use(express.urlencoded({extended : false}))
    ==>> [미들웨어 함수로], [서버에서 데이터를 받기 전, 자바스크립트코드로 구문분석해준다]


[11. 파일에 접근하기 위한, 내장패키키지와 사용]

        **[ 전체적 개요 ]
            - 0. [json]파일을 만들어서, 배열 하나를 만들어둘것.   ==> 단순히 [] 만 적어주면 됌.

            - 1. 파일의 데이터를 가져옴 [req.body.name태그 이름]
                    * 원시 텍스트 데이터    ==> 데이터를 가져올때는 항상 [원시 텍스트 데이터]로 가져온다.

                [ const userName = req.body.username;    ]

            - 1-1. const app = express()
            -      app.use(express.urlencoded({extended : false})) 를 통해 [가져온 텍스트데이터]를 [자바스크립트 코드 데이터] 로 자동 변경하게만듬

            - 2. fs(파일시스템)패키지 , path(경로) 패키지를 불러옴

                [const fs = require("fs")]   [const path = require("path")]
                    * 내장 패키지  [ fs ],  [ path ] 를 불러올것
                    * [fs]는 파일을 [읽고], [쓰고],  [저장] 하는데 사용
                    * [path]는 [파일의 경로를 추적]하는데 사용

            - 3. 가져온 데이터를 저장하고자 하는 파일의 [경로를 저장]

                [ const filePath =  path.join(__dirname , "data", "user.json")         ]   ==> 파일의 정확한 위치정보를 잡음
                        * __dirname : 디렉토리 이름 명령어
                        * "data", "user.json"       ==>> 하나씩 파고들어서 파일에 접근  [ex) 1, 2, 3, ms.json]  : 1번폴더 안의 2번폴더 안의 3번폴더 안의 ms.json파일

            - 4. 파일의 경로에 있는 내용을 [읽음]
                    * 원시 텍스트 데이터 ==> json 안에 있는것을 읽은것이니까
                [ const fileData = fs.readFileSync(filePath)              ]       ==> [filePath 경로의 파일을 읽고], [fileData 변수에 저장]

            - 4-1. [읽어온 텍스트 데이터를 [자바스크립트 데이터로 분석] ]

                [ const existingUsers = JSON.parse(fileData)    ]
                        * JSON.parse()  :  텍스트를 자바스크립트코드로
                        * JSON.stringify() : 자바스크립트코드를 텍스트로
                
            - 5. [ [자바스크립트 데이터]로 분석된 데이터 안에 [1번에서 받아온 데이터를 추가(push)]  ]
                [ existingUsers.push(userName)        ] 
                    * [push 등의 코드를 조작하는 자바스크립트 코드]는
                            [자바스크립트 데이터만] [조작이 가능하다]
                    * 받아온 데이터는 [원시 텍스트 데이터]지만, [app.use] 를 통해 [받아온 데이터는 전부 자바스크립트 데이터로] 저장되기에, 쓸 수 있는것. 

            - 6. [받아온 데이터를  [실제 존재는 파일에 쓰고 저장]  ]
                [ fs.wirteFileSync(filePath, JSON.stringify(existingUsers))          ]       ==> 파일을 쓰고 저장
                        *Sync 라는 코드는 [즉시] 라는 뜻이다.
                        * [filePath] 라는 경로에(user.json 파일), [JSON.stringify(existingUsers)] 라고 쓰겠다. [파일로서 저장]

        ** [ 헷갈릴 수 있는 것  ]
            0. 텍스트 데이터와, 자바스크립트 데이터를 헷갈리지 말자
            1. [받아오는 데이터]는 [텍스트 데이터], 
                [사용 가능한 데이터]는  [자바스크립트 데이터]이다.
            2. [데이터를 받아온다 한들], [그걸을 자바스크립트 배열에 추가한다 한들]
                [정작 [파일]로 저장되지는 않는다.]

                *** 파일을 열어, 데이터를 배열에 집어넣고, 집어넣어진 배열을 파일에 쓰고 저장하여야, 파일에 저장됨을 헷갈리지 말자.
                        

        **[ 기초적 지식 ]
            0. [json 파일]은 [원시 텍스트만 읽을 수 있다.]  [ 자바스크립트 코드는 읽을 수 없다.]
            1. [데이터를 뽑아올 때는, [원시 텍스트로 가져와진다.]]
            2. [ [원시 텍스트 데이터]는 코드로 작업 할 수 없다!]
            2-1. [ [자바스크립트 코드 데이터]는 코드로 작업 할 수 있다!]
                * 코드작업을 하려면 [텍스트데이터를] [자바스크립트 코드 데이터로] 변경해주는 JSON.parse() 가 필요하다.


[12. HTML 파일과 node.js[서버] 사이의 연결]
        * res.sendFile()

    app.get("/recommend", function(req,res){
        const htmlFilePath = path.join(__dirname,"views","recommend.html")
        res.sendFile(htmlFilePath)
    })
    app.get("/restaurants", function(req,res){
        const htmlFilePath = path.join(__dirname,"views","restaurants.html")
        res.sendFile(htmlFilePath)
    })
    ...


[12-1. CSS, javaScript 같은 정적파일과 nodejs 연결!]

    HTML 파일
        : [get, post] 안의 [함수에서], [res.sendFile(   HTML 파일이름이 담긴 PATH  )] 로 연결

    CSS, JavaScript 파일
        :   [정적 파일]로서, [폴더를 하나 만들어, 집어넣고]  

        :   [HTML 파일 안에서는 link 와 script로 연결하고]

        :   [ExpressJS 안에서는, 미들웨어함수로 위치를 받아 연결]

                *app.use(express.static("정적파일있는 폴더이름"))

[13. res.send() 의 오류(새로고침시, 양식을 다시제출하는)를 방지하는,  res.redirect()]

    - recommend 페이지에, form 에서 값을 받아오고, 저장후에, 확인페이지로 넘어가는 작업

    app.get("/recommend", function(){
        res.sendFile(HTML파일경로)
    })
    app.post("/recommend", function(){
        const fileData = req.body;
        ...
        fs.wirteFileSync(JSON.(파일데이터))

        res.redirect("/confirm")
    })

    ==>> 자신의 폼에 submit 을 하면, 그대로 자신의 페이지에서 값을 받아, 파일에 저장하고
            /confirm 페이지로 이동한다

[14. 템플릿과, 템플릿 엔진의 사용 ejs  [1단계 - 세팅]]
    1. npm install ejs

    2. app.set("views",path.join(__dirname,"views"))        // 탬플릿(기존 html) 이 있는 곳은 views 라는 폴더이다
    3. app.set("view engine","ejs")                         // 탬플릿을 읽는 엔진으로는 "ejs" 템플릿 엔진을 사용하겠다.

    4. [모든 HTML 파일 확장자] [.ejs 로 변경]

[14-1. 템플릿과, 템플릿 엔진의 사용 ejs  [2단계 - 사용 ,장점]]

    [1. 간단해지는 코드 ]
        * res.render("ejs파일이름")

        app.get("/recommend", function(req,res){
            res.render("recommend")
        })
        app.get("/restaurants", function(req,res){
            res.render("restaurants")
        })
        ...

    [2. HTML 코드의 [서버측에서 동적인 사용!] ********************************************************** ]
        -   이게 진짜 사용 이유!!
            * res.render("ejs파일이름", {동적으로작동시킬코드이름 : 값}) **********************************
    
        - 1. HTML 코드에, EJS 구문을 넣고, [동적으로 작동시키기]
            1) HTML 코드 안에서 <%= 동적으로작동할코드이름 %>
            2) [서버측에서] [동적으로 작동한 HTML 코드이름 과 연결]
            3) 동적으로 작동시키기

            ex) <p>  "hi" <%= numberOfRestaurant %>   </p>                      // HTML [P 태그 안]에 [SPAN 처럼 입력]

                app.get("/restaurants", function(req,res){
                    const filePath = path.join(__dirname, "data","restaurants.json")
                    const fileText = fs.readFileSync(filePath)
                    const storedRestaurants = JSON.parse(fileText)              // json 파일에 접근해, 읽고, 자바코드로

                    res.render("restaurants", {numberOfRestaurant : storedRestaurants.length} ) // [HTML파일의 동적으로 작동할코드]를 [동적으로 변경시킴]
                })
            
        - 2. HTML 코드에, EJS 구문을 넣어, [HTML 코드 반복시키기] + 동적으로 작동시키기 + [ if 문 작성하여 HTML 코드 동적으로 바꾸기]

        <% if (numberOfRestaurant ===0) { %>
            <p> no recommend restaurant exist </p>
        <% } else { %>
    -       <% for (const restaurant of restaurants) { %>  
                <li class="restaurant-item">
                    <article>
    -               <h2>     <%= restaurant.name %>     </h2>
                    <div class="restaurant-meta">
    -                   <p> <%= restaurant.cuisine %>  </p>
    -                   <p> <%= restaurant.name %>  </p>
                    </div>
                    <p>
    -                   <%= restaurant.description %> 
                    </p>
                    <div class="restaurant-actions">
    -                   <a href=""> <%= restaurant.website %> </a>
                    </div>
                    </article>
                </li>
    -       <% } %>
        <% } %>
        * 열고닫는 태그를 [HTML에도 쓸 수 있어진다.] ==>> [for 반복문을 JavaScript처럼 사용 할 수 있다!!]
        * [.json의 값들을] 가져와서 [HTML 코드]를 [동적으로 바꿀 수 있다.]
        * [.js] 에서 할 일은 [추가적인 render()의 키,값 쌍을 집어넣는 것이다.]

            res.render("restaurant", numberOfRestaurant : storedRestaurants.length, restaurants : storedRestaurants)

        해석 : HTML 코드를 [.json의 배열에 대해 반복문을 작성] [for - of 반복문]
                [한 배열 안에 있는 객체들을 하나씩 소환], [각 값의 동적인 값으로 적용]

        [중요한점]:  1. ejs의 [구문은] <%   %> 로 표시한다.
                    2. ejs의 [단일 값들] 은 <%=   %> 로 표시한다.
                    3. ejs의 [구문을 사용할 때에는] <% for(){  %>  처럼 [한쪽 중괄호만 표시하고]
                        [HMTL 코드 에서, 구문을 종료하고 싶을 때]    <% } %> 처럼, [다른쪽 중괄호로 닫는다.]

        - 3. [단순히 딱 떨어진 HTML 코드를 잘라], [파일에 넣고], [한 폴더에 집어넣으면] [어디든 그 코드를 끼워넣을 수 있다.]
                * HTML 코드의 [변수화?]

            <header id="main-header">
            <div id="logo"><a href="/index">Eatwell</a></div>

            ...

            <span></span>
            </button>
            </header>          
            
            * 이러한 header HTML 코드를 잘라, [header.ejs] 에 집어넣고, [include] 라는 폴더를 만들어 집어넣어준다.
            
            ** 우리는 모든 HTML 파일에 이 header가 들어가므로, 
                        [모든 HTML 파일의 header 안에 있는 코드들 대신]
                <head>
            -   <%-  include("include/head") %>
                </head>
                <main>
            -   <%-  include("include/header") %>
            -   <%-  include("include/aside") %>
                </main>
                        처럼 사용하면, [마치 변수에 저장하고 사용하듯, HTML 코드를 사용할 수 있다.]
            
            사용 : 모든 반복되는 구문에 대하여 사용 
                        EX) header, aside, footer 등 [모든 페이지가 같은 코드이름]

[15. 동적 라우트를 연결]

    - [1. 동적 라우트를 만든다. [/:id] , [req.params.id;]       ]
        app.get("/restaurants/:id" ,function(req,res){
            const retaurantId = req.params.id;
            res.render("restaurants-detail", {rid : retaurantId})

        })
-              * URL(특정 id)을 통해, [URL에 의한 아이디값을 받아온다].    
              * ["/restaurants/:id"], [req.params.id;]

                  
    - [2. recommned에서 form을 받아와 저장할때 고유의 id값을 만들어서 같이 저장하도록 한다.]

        app.post("/recommend", function(req,res){
            const restaurant = req.body;
            restaurant.id = uuid.v4();
        )}

        -   를 통해, 고유한 ID 값도 함께 저장되도록 만든다.
            * uuid를 설치하고, require() 로 불러오는것도 잊지 말것.

    ==>> IF CHECK에서 , [1번과 2번을 비교하여 Id에 맞는 객체의 값을 가져올것이다.]


    - [3. restaurants-detail.ejs 파일에서, 불러와질 각 값을 ejs구문으로 작성한다 (나의 키는 title 로 정했다.)].


    - [4. for 문과 if문을 통하여], 
-       1) [URL을 통해 받아온 id 값] 
            ==>>  [json파일에서 온], [id값으로 만들어진 li]의 [고정된 앵커태그 주소에 의해 나온 URL의 값]을 받아 [만든 값]
            * restaurant-detail 에 접근하기 위한 버튼의 앵커태그는 [만들어질때, 고정됨을 명심하자]
            
-       2) [JSON 파일 자체에 있는 [모든 객체들] 을 검사하여 각 ID값을 뽑아낸 값중 하나!]
-       위의 1) 과 2) 가 동일하다는 조건을 가진다면 [그 조건을 만족하는 JSON 파일의 객체를 하나 뽑아, 거기서 나온 값을 사용]

        app.get("/restaurants/:id" ,function(req,res){
            const retaurantId = req.params.id;
            
            const filePath = path.join(__dirname,"data","restaurant.json")
            const fileText = fs.readFileSync(filePath)
            const storedRestaurants = JSON.parse(fileText)

            for (const restaurant of storedRestaurants){
                if(restaurant.id == retaurantId){
                    return res.render("restaurants-detail", {title : restaurant})
                }
            }
        })

        // id가 같은 것을 찾았으면 [루프를 멈추기 위해 return 을 사용]
        // 같은 id를 찾았다면, [어떤 한 배열의 객체가 선택된 것이고,] [storedRestaurants 안의 값들이 restaurant로 받아와지고 ]
        // "restaurants-detail" 에서, [title 이라는 ejs 구문을 가진 코드를], [for 루프의 restaurant, 즉, storedRestaurants로 바꿔준다.]


    * 처리순서 : 1. [HTML의 restaurant] 에 있는 [버튼]이 href = "restaurants/id" 이것이므로, domain/restaurants/id 라는 URL에 접근한다.
                                                                * 최종적으로 [id] 조차 [동적으로 만들것]이다.
                    최종 : href = "restaurants/ <%= restaurant.id %>"

                2. URL에 접근하면, get에 의해 ["restaurants/:id"] 에 접속했으므로,
                    [req.params.id]에 의해, id값이 생성되고, [render에 의해] [restaurant-datail.ejs 를 불러온다.]

                3. [restaurant-datail 페이지]는 [restaurant.json] 의 값을 ejs로 받아왔는데
                    [추가적으로], [params.id 에 의한 값도 받아온다.]
                    * 이때, HTML의 CSS와 JavaScript 파일의 경로가, 상대경로라면, 오류가난다. [앞에 / 를 붙여서 절대경로로 만들어주자]

                4. [이제, json 파일에 push 할때, [고유한 아이디 값을 지정하며, 저장한다.]]
                    * 랜덤함수로, id를 정해주는 패키기 [uuid] 패키지를 설치한다. npm install uuid

            -   5. 최종
                    [restaurant.json]의 모든 데이터를 불러와서 
                    [for - of 를 통해, 또한 IF 를 통해 [모든 배열안의 객체안의 id값]을 [URL에 의해 받아온 ID 값과 비교]]
                        * IF문의 CHECK는 
                            [URL에 입력되어, ID값으로 받아와진 값] === [.JSON 에 입력된 ID 값]
                            이라는 조건이 들어가야한다.
                    [그 값으로 각각의 요소를 채운다.]


16. 상태코드 추가한 후, render 하기
        res.status(코드번호).render()


17. [다른 폴더에, 다른 파일을 만들어!! ] [코드를 쪼개 함수를 만들어, 중복되는 코드 줄이기]
        * 리팩토링
        
        ==>> 장점 :  [중복된 코드의 제거]
                    [ 코드 변경시, 한 파일에 있는 것만 변경해도 한번에 전부 같은것들이 변경됌]

                비슷한것 : [ejs의 중복된 HTML코드 제거] include()

        * KEY : module.exports( { 외부에서사용할키: 정의한이름 } )
                module.exports( router )
                각 파일에, 각각 패키지 require하기 [필요한것들에 한해서]
                [함수를 불러올때], [사용할 곳]에 [함수가 들어있는 내 파일 이름]을 [require 하기]
                path.join(__dirname) 은 자신의 위치가 기준이점, [상위 폴더로 가려면] [".."] 을 추가해야하는 점

        * 중요 : app.get( function(){
                })
                [안에 있는 모든] [패키지를 사용하는 값이나 연관되어 있는 값들은] [전부 한 파일에 몰아서 저장해야한다]
                    ==>> 함수의 특성상, [함수 안에 정의한 변수들은, return없이 함수 바깥에서 사용이 불가능하므로!!!]


        1) util 폴더 만들기(이름은 고정x), 안에 쪼개넣을 함수를 가진 .js파일 만들기

        2) [중복되는 코드를 가져와 함수형으로 바꾸기]

                *단, 반드시 [한 라우터 내에 쓰였던 모든 함수들은 [전부] 가져와서 한 파일에 묶어야한다.]
                    : 함수로 정의하는 특성상, 함수 내에 정의한 변수이름은, 밖으로 빼서 사용할 수 없기 때문
                * __dirname 의 경로는 [자기 자신을 기준점으로 하므로, [".."]을 통해, 상위 폴더로 한번 가 주었다.]
            const fs = require("fs")
            const path = require("path")
                    
            const filePath = path.join(__dirname,"..","data","restaurant.json")
                    
            function bringRestaurantData(){
                const fileText = fs.readFileSync(filePath)
                const storedRestaurants = JSON.parse(fileText)
                    
                return storedRestaurants     
            }
                    
            function writeRestaturantData(storedRestaurants){
                fs.writeFileSync(filePath, JSON.stringify(storedRestaurants))
            }



        3) [내 파일 노출시키기]  module.exports = {}
                : 코드를 리팩토링하게 위해 정리한 파일은, [노출시켜야], [상대편에서 받아서] [사용가능하다]

            module.exports = { bringRestaurantData : bringRestaurantData, writeRestaturantData : writeRestaturantData}

                            [앞의 키는 상대편에서 사용할 키, 뒤의 값은 [내가 정한 함수이름]]
                            * 대부분은 [헷갈리지 않기 위해 같은 값을 사용]

        4) [상대편에서 받아서 사용하기] =>>  const 변수이름 = require(위치)
            
            const resData = require(./util/restaurantData)
                * require 경로는 항상 [확장자가 없음을 명시]
                * [상대경로를 사용하는것 명시]

        5) [사용]
                : 함수처럼 사용하돼, [app.get 처럼] require을 담은 변수 객체를 소환하여, 붙여사용
            
            const storedRestaurants = resData.bringRestaurantData();

            resData.writeRestaturantData(storedRestaurants) 



18. [다른 폴더에, 다른 파일을 만들어] [ 라우트들을 쪼개 넣어] [라우트를 깔끔하게 관리하기 ==> 라우터 (get, post 등)]
    ==>> [리팩토링]이라고 부른다.
            1] 저장
                1) routes 폴더 생성, .js 파일 생성

                2) [새 파일에, express 라우트를 생성] 
                    const express = require("express")
                    const router = express.Router();

                3) 새파일의 app ==>  router로 교체

                4) [새파일의 라우터 내보내기]
                    module.exports = router

            2] 사용 ==> require
                1) 불러오기
                    const defaultRouter = require("./routes/default")

                2) 사용
                    app.use("/",defaultRouter)
                        ==>> [app.use() 는 모든 요청을 처리하는 미들웨어로]
                            ["/"로  시작되는 모든 값들은 전부 defaultRouter 를 거쳐서 들어와라 ] 라는 뜻이다.
                            [미들웨어 = 필터] 라고 생각하면 편하다
                            [defaultRouter] 에 없는 요청이면 다음 app.get 등으로 넘어간다.

                * 리팩토링후, 내 파일을 참조한 resData 같은 것들을, 쓰일 곳에 다시 집어넣어주고, 경로를 잘 조정한다.
                            사용하는 uuid 나 fs, path 위치도 전부 조정하거나, 삭제하거나, 이동한다.
                     resData = require("./util/restaurantData")

                        참조: [ "." ==> 같은 위치의 폴더]
                              [ ".." ==> 상위 위치의 폴더]


    유의할점:
        1) 내 파일을 [내 다른파일에 require 하기]
         2) 각 파일마다 필요한 패키지는 require 해서 사용하기 [ fs, path 등의 패키지를 쓰는 파일은 각각 전부 해주어야함]
        3) [쪼갠 코드를 모아놓은 파일에는] [module.exports ={}] 로, 노출하고자 하는 함수를 표기하기 [다른일에서 쓸 키 : 함수이름] 
                            * 단순히 함수이름만 사용한다 () 없이
        4) path.join(__dirname,) 을 사용할때, 완전히 다른폴더로 이동하려면 , [".."] 으로 상위폴더로 올라가는 값을 넣어서 위치를 이동해야한다.

19. 쿼리 매개변수(파라미터) 를 사용하여, [레스토랑 리스트 이름차순으로 정렬하기]

    0. [데이터배열]을 [정렬] = 배열.sort()      // 고급함수니 그저 작동법을 외우자

        storedRestaurants.sort(function(resA,resB){
            if( resA.name > resB.name){
                return 1
            }
            return -1
        })

        결과 :  1은 그대로, -1은 뒤집힌다. 
        ==>> 알아서 비교하면서 [알파벳 순서대로 정리될것이다.]

    2. 쿼리 매개변수 생성
        : [버튼을 눌렀을때, query매개변수를 생성하는 방법]

        : ejs 파일에서, hidden 값으로 <input type = "hidden" name = 이름, value = 값>
          form을 감싸, button 만들어, 값을 받아내기

    3. 쿼리 매개변수를 받아오기
        let order = req.query.order                 [마치 post로 받은 form의 객체값을, req.body 로 받듯이]

    4. 혹시나, 쿼리 매개변수가 잘못되었을 것을 확인하며, 검증
        if( order !== "asc" && order !=="desc"){
            order = "asc";
        }

    5. [정방향 정렬], [반대방향 정렬] 코드를 만들기

        if(order =="asc" && resA.name > resB.name){
            return 1 // 정방향정렬
        }
        if(order =="desc" && resB.name > resA.name){
            return 1 // 역방향정렬
        }
        return -1
        
        ==>> order가 asc = 정방향
                    desc = 역방향
        ==>> 이제 버튼을 눌렀을때, [value가 asc로 되냐], [desc로 되냐] [동적 전달만 하면 된다.]

    6. ejs 파일에가서, 동적으로 전달
        value = " <%= nextOrder  %> " 
    
    7. asc, desc가 바뀌는 논리 만들기 ******************************************************
        let order = req.query.order;
        let nextOrder = "desc"

        if(order === "desc"){
            nextOrder = "asc";
        }
        ==> [처음] nextOrder = desc;
            [클릭] => if체크에 의해 => [order에 desc] => [nextOrder => asc]
            [클릭] => order는 asc이므로, [nextOrder의 값은 유지] => [nextOrder = desc]
            [클릭] => if체크에 의해 => [order에 desc] => [nextOrder => asc] ... 

-            let  a = 받아오는값
-            let b = dasc
-            처음 은 = b
-            if( a === dasc)
-                b= asc
-            ==> b는 asc로 들어가서 a는 다시 asc가돼
-            ==> if 체크를 빗겨나가 b=dasc로 다시들어가고
-            ==> URL은 다시 A를 DASC로 만들고
-            ==> 그러므다시 b  는 ASC로 되어 URL에 들어가고 ....\

        8. ejs 템플릿에 nextOrder 전달
            res.render("", {nextOrder:nextOrder})



- [백엔드를 사용한 [서버이용 코드를 작성하는 순서]] *******************************************************************************

0. [html, css, javaScript 코드 작성]

1. [view폴더를 를 사용한 ejs 파일 바꾸기]

2. [include 폴더를 사용한, include [ ejs 코드 리팩토링]]
        / 코드 잘라넣기 / <%- include("폴더/파일")%>
3. [util 폴더를 이용한 [js 리팩토링]]
        / function xy(){}    /   module.exports = {xy}  / const x= require(./util/)  /  x.xy
4. [router 폴더를 사용한 [라우터 리팩토링]]
        / express.Router() / module.exports = router / const x = require(./router/) / app.use(x)

을 기본적으로 리팩토링 하고 들어가야한다!  [그래야 편하다!]




            