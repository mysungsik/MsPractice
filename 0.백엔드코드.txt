[1. http 패키지 불러오기]  
const http = require(http)      // 물론 변수이름은 마음대로 

        HTTP PAKEAGE 둘러보기 ==>> https://nodejs.org/dist/latest-v18.x/docs/api/http.html
        [노드JS에서 제공하는] 유틸리티 [메서드와 프로퍼티]로 가득찬 [객체]가 반환된다.

[2. sever 만들기]
const sever = http.createServer()

[3. sever에 수신대기 포트 만들기]
server.listen(3000)         // 3000은 마음대로 입력한 [포트번호]이다.
                            // [여기까지 입력하면, 포트3000에 대한 요청을 수집하라 라는 코드이다.]

[4. 요청과, 응답 함수를 만들어서 서버에 집어넣기]

    - 앞선 2번의 서버만드는 코드에 추가

    const http = require(http) 

    function handleRequest(request, response){
        response.statusCode = 200;
        response.end("HTML태그 입력")
    }
    const sever = http.createServer( handleRequest )

    server.listen(3000)

    - createServer() 의 첫번째 파라미터로 [requestListener] 를 요구하므로, 집어넣는 것이다.
    - 또한, 만들어진 서버[포트번호 3000]에 요청이 들어올때마다, handleRequest 함수가 실행될것이다.

    [statusCode] 는 브라우저에게 [요청이 성공했는지에 대한 여부를 알리는 방법이다.]
    https://developer.mozilla.org/ko/docs/Web/HTTP/Status
    [200] 은 OK 를 나타내는 코드이다.

[5. statusCode, end()]

    1) statusCode
        : [브라우저]에게 [요청의 성공여부를 알려주는 코드]
    2) end()
        : 요청에 성공했다면, [응답준비를 마치고, 응답에 대한 것을 보낼 수 있다.]
        : [기본적으로 HTML태그를 보내보자.]


[6. request 와 response]        ****************************************************************

    1) request : [브라우저에서 서버로 보내는 요청들 중 하나]
                대표적으로 [request.url] 으로 포트 뒤의 URL 주소를 받아온다.
    2) response : [ 서버에서 브라우저로 보내는 응답 ]
                대표적으로 response.statusCode = ""
                          response.end()

[7. new Date().toISOString()]

    new Date() ==> 날짜 객체를 생성
    toISOString() ==> 문자열로 변환 함수

[8. [node.JS] 그리고 [타사패키지 Express.js]]

    nodeJS  : javaScript 의 언어를 사용하는 [브라우저 외부에 있는 javaScript], [서버에 적합한 프로그래밍 언어이다]
    nodeJS의 한계   : 많은 양의 코드를 적어야하고, 복잡하게 사용해야하는 기능들이 많다. [그래서 타사패키지를 사용할것이다.]
    타사패키지 설치 : npm init, npm install 패키지이름      을 통해 설치한다.
    Express.js 의 장점  : 짧고 간결한 코드, 다양하고 편리한 기능
    Express.js 의 사용 

[9. node express의 사용]
[ 파일을 주는 get, 파일을 받는 post ]
[ 파일을 주는 res, 파일을 받는 req ]
************************* [   get("", function(req,res){})   ] , [   post("", function(req,res){})  ]   ] **************************************

    1) get("", function(req,res){})
        :nodeJS 의 request와 response 를 합친 형태 중, *** [보내는 형태] ***

        get("/jsjs",  function(req, res){
            res.send("<h1> hi </h1>")
        })

        ==>> localhost:3000/jsjs 에 접근했다면, [응답하라(res)] = "<h1> hi </h1>" 을 적음으로써!



    2) post("", function(req,res){})
        :nodeJS 의 request와 response 를 합친 형태 중, *** [받는 형태] ***

        post("/msms", function(req,res){
            const userName = req.body.username;
            res.send("<h1> hi </h1>")
        })

        ==>> localhost:3000/msms 에 접근했다면, 

            req.body.username  ==>> [받아라(req)], [username] 이라는 [HTML의 name]을 [가진 요소의 데이터]를
        -   req.body   ==>> [form에서 나온 데이터 [전부]!]
        -   req.body.username ==> [forem에서 나온 데이터중, username이라는 name 을 가진 데이터만]

            [응답하라(res)], "<h1> hi </h1>" 라고 나타냄으로써!

    - 파일을 줄것이면 애초에 [get] 으로 접근하고.
    - 파일을 받을 것이면 애초에 [post] 로 접근한다.
    - [POST] 로 접근한 이유는 <form aciton="url 뒤의 주소" method = "POST"> 로 method를 post로 설정했기 때문이다.


    - 장점 = 간단하다, 사용방도가 많다, 
    -       statusCode 가 기본으로 200 으로 되어있어서 쓸 필요가 없다.

[10. 받아온 데이터를 다시 자바스크립트 코드로 변환하기] [use 를 사용하여!] + [미들웨어 함수]
    : 폼 양식을 통해, [브라우저에서 서버로] [데이터를 보냈다.]
        [그럼에도 불구하고, 데이터는 [자바스크립트코드가 아닌] [그저 데이터의 일부일뿐]]
        [ 그러므로, 자바스크립트에서 읽을 수 있도록 구문 분석을 해야한다.]

    const express = require("express")
    let app = express()

    app.use(express.urlencoded({extended : false}))
    ==>> [미들웨어 함수로], [서버에서 데이터를 받기 전, 자바스크립트코드로 구문분석해준다]


[11. 파일에 접근하기 위한, 내장패키키지와 사용]

        **[ 전체적 개요 ]
            - 0. [json]파일을 만들어서, 배열 하나를 만들어둘것.   ==> 단순히 [] 만 적어주면 됌.

            - 1. 파일의 데이터를 가져옴 [req.body.name태그 이름]
                    * 원시 텍스트 데이터    ==> 데이터를 가져올때는 항상 [원시 텍스트 데이터]로 가져온다.

                [ const userName = req.body.username;    ]

            - 1-1. const app = express()
            -      app.use(express.urlencoded({extended : false})) 를 통해 [가져온 텍스트데이터]를 [자바스크립트 코드 데이터] 로 자동 변경하게만듬

            - 2. fs(파일시스템)패키지 , path(경로) 패키지를 불러옴

                [const fs = require("fs")]   [const path = require("path")]
                    * 내장 패키지  [ fs ],  [ path ] 를 불러올것
                    * [fs]는 파일을 [읽고], [쓰고],  [저장] 하는데 사용
                    * [path]는 [파일의 경로를 추적]하는데 사용

            - 3. 가져온 데이터를 저장하고자 하는 파일의 [경로를 저장]

                [ const filePath =  path.join(__dirname , "data", "user.json")         ]   ==> 파일의 정확한 위치정보를 잡음
                        * __dirname : 디렉토리 이름 명령어
                        * "data", "user.json"       ==>> 하나씩 파고들어서 파일에 접근  [ex) 1, 2, 3, ms.json]  : 1번폴더 안의 2번폴더 안의 3번폴더 안의 ms.json파일

            - 4. 파일의 경로에 있는 내용을 [읽음]
                    * 원시 텍스트 데이터 ==> json 안에 있는것을 읽은것이니까
                [ const fileData = fs.readFileSync(filePath)              ]       ==> [filePath 경로의 파일을 읽고], [fileData 변수에 저장]

            - 4-1. [읽어온 텍스트 데이터를 [자바스크립트 데이터로 분석] ]

                [ const existingUsers = JSON.parse(fileData)    ]
                        * JSON.parse()  :  텍스트를 자바스크립트코드로
                        * JSON.stringify() : 자바스크립트코드를 텍스트로
                
            - 5. [ [자바스크립트 데이터]로 분석된 데이터 안에 [1번에서 받아온 데이터를 추가(push)]  ]
                [ existingUsers.push(userName)        ] 
                    * [push 등의 코드를 조작하는 자바스크립트 코드]는
                            [자바스크립트 데이터만] [조작이 가능하다]
                    * 받아온 데이터는 [원시 텍스트 데이터]지만, [app.use] 를 통해 [받아온 데이터는 전부 자바스크립트 데이터로] 저장되기에, 쓸 수 있는것. 

            - 6. [받아온 데이터를  [실제 존재는 파일에 쓰고 저장]  ]
                [ fs.wirteFileSync(filePath, JSON.stringify(existingUsers))          ]       ==> 파일을 쓰고 저장
                        *Sync 라는 코드는 [즉시] 라는 뜻이다.
                        * [filePath] 라는 경로에(user.json 파일), [JSON.stringify(existingUsers)] 라고 쓰겠다. [파일로서 저장]

        ** [ 헷갈릴 수 있는 것  ]
            0. 텍스트 데이터와, 자바스크립트 데이터를 헷갈리지 말자
            1. [받아오는 데이터]는 [텍스트 데이터], 
                [사용 가능한 데이터]는  [자바스크립트 데이터]이다.
            2. [데이터를 받아온다 한들], [그걸을 자바스크립트 배열에 추가한다 한들]
                [정작 [파일]로 저장되지는 않는다.]

                *** 파일을 열어, 데이터를 배열에 집어넣고, 집어넣어진 배열을 파일에 쓰고 저장하여야, 파일에 저장됨을 헷갈리지 말자.
                        

        **[ 기초적 지식 ]
            0. [json 파일]은 [원시 텍스트만 읽을 수 있다.]  [ 자바스크립트 코드는 읽을 수 없다.]
            1. [데이터를 뽑아올 때는, [원시 텍스트로 가져와진다.]]
            2. [ [원시 텍스트 데이터]는 코드로 작업 할 수 없다!]
            2-1. [ [자바스크립트 코드 데이터]는 코드로 작업 할 수 있다!]
                * 코드작업을 하려면 [텍스트데이터를] [자바스크립트 코드 데이터로] 변경해주는 JSON.parse() 가 필요하다.


[12. HTML 파일과 node.js[서버] 사이의 연결]
        * res.sendFile()

    app.get("/recommend", function(req,res){
        const htmlFilePath = path.join(__dirname,"views","recommend.html")
        res.sendFile(htmlFilePath)
    })
    app.get("/restaurants", function(req,res){
        const htmlFilePath = path.join(__dirname,"views","restaurants.html")
        res.sendFile(htmlFilePath)
    })
    ...
    
[12-1. CSS, javaScript 같은 정적파일과 nodejs 연결!]

    HTML 파일
        : [get, post] 안의 [함수에서], [res.sendFile(   HTML 파일이름이 담긴 PATH  )] 로 연결

    CSS, JavaScript 파일
        :   [정적 파일]로서, [폴더를 하나 만들어, 집어넣고]  

        :   [HTML 파일 안에서는 link 와 script로 연결하고]

        :   [ExpressJS 안에서는, 미들웨어함수로 위치를 받아 연결]

                *app.use(express.static("정적파일있는 폴더이름"))

[13. res.send() 의 오류(새로고침시, 양식을 다시제출하는)를 방지하는,  res.redirect()]

    - recommend 페이지에, form 에서 값을 받아오고, 저장후에, 확인페이지로 넘어가는 작업

    app.get("/recommend", function(){
        res.sendFile(HTML파일경로)
    })
    app.post("/recommend", function(){
        const fileData = req.body;
        ...
        fs.wirteFileSync(JSON.(파일데이터))

        res.redirect("/confirm")
    })

    ==>> 자신의 폼에 submit 을 하면, 그대로 자신의 페이지에서 값을 받아, 파일에 저장하고
            /confirm 페이지로 이동한다

[14. 템플릿과, 템플릿 엔진의 사용 ejs  [1단계 - 세팅]]
    1. npm install ejs

    2. app.set("views",path.join(__dirname,"views"))        // 탬플릿(기존 html) 이 있는 곳은 views 라는 폴더이다
    3. app.set("view engine","ejs")                         // 탬플릿을 읽는 엔진으로는 "ejs" 템플릿 엔진을 사용하겠다.

    4. [모든 HTML 파일 확장자] [.ejs 로 변경]

[14-1. 템플릿과, 템플릿 엔진의 사용 ejs  [2단계 - 사용 ,장점]]

    [1. 간단해지는 코드 ]
        * res.render("ejs파일이름")

        app.get("/recommend", function(req,res){
            res.render("recommend")
        })
        app.get("/restaurants", function(req,res){
            res.render("restaurants")
        })
        ...

    [2. HTML 코드의 [서버측에서 동적인 사용!] ********************************************************** ]
        -   이게 진짜 사용 이유!!
            * res.render("ejs파일이름", {동적으로작동시킬코드이름 : 값}) **********************************
    
        - 1. HTML 코드에, EJS 구문을 넣고, [동적으로 작동시키기]
            1) HTML 코드 안에서 <%= 동적으로작동할코드이름 %>
            2) [서버측에서] [동적으로 작동한 HTML 코드이름 과 연결]
            3) 동적으로 작동시키기

            ex) <p>  "hi" <%= numberOfRestaurant %>   </p>                      // HTML [P 태그 안]에 [SPAN 처럼 입력]

                app.get("/restaurants", function(req,res){
                    const filePath = path.join(__dirname, "data","restaurants.json")
                    const fileText = fs.readFileSync(filePath)
                    const storedRestaurants = JSON.parse(fileText)              // json 파일에 접근해, 읽고, 자바코드로

                    res.render("restaurants", {numberOfRestaurant : storedRestaurants.length} ) // [HTML파일의 동적으로 작동할코드]를 [동적으로 변경시킴]
                })
            
        - 2. HTML 코드에, EJS 구문을 넣어, [HTML 코드 반복시키기] + 동적으로 작동시키기 + [ if 문 작성하여 HTML 코드 동적으로 바꾸기]

        <% if (numberOfRestaurant ===0) { %>
            <p> no recommend restaurant exist </p>
        <% } else { %>
    -       <% for (const restaurant of restaurants) { %>  
                <li class="restaurant-item">
                    <article>
    -               <h2>     <%= restaurant.name %>     </h2>
                    <div class="restaurant-meta">
    -                   <p> <%= restaurant.cuisine %>  </p>
    -                   <p> <%= restaurant.name %>  </p>
                    </div>
                    <p>
    -                   <%= restaurant.description %> 
                    </p>
                    <div class="restaurant-actions">
    -                   <a href=""> <%= restaurant.website %> </a>
                    </div>
                    </article>
                </li>
    -       <% } %>
        <% } %>
        * 열고닫는 태그를 [HTML에도 쓸 수 있어진다.] ==>> [for 반복문을 JavaScript처럼 사용 할 수 있다!!]
        * [.json의 값들을] 가져와서 [HTML 코드]를 [동적으로 바꿀 수 있다.]
        * [.js] 에서 할 일은 [추가적인 render()의 키,값 쌍을 집어넣는 것이다.]

            res.render("restaurant", numberOfRestaurant : storedRestaurants.length, restaurants : storedRestaurants)

        해석 : HTML 코드를 [.json의 배열에 대해 반복문을 작성] [for - of 반복문]
                [한 배열 안에 있는 객체들을 하나씩 소환], [각 값의 동적인 값으로 적용]

        [중요한점]:  1. ejs의 [구문은] <%   %> 로 표시한다.
                    2. ejs의 [단일 값들] 은 <%=   %> 로 표시한다.
                    3. ejs의 [구문을 사용할 때에는] <% for(){  %>  처럼 [한쪽 중괄호만 표시하고]
                        [HMTL 코드 에서, 구문을 종료하고 싶을 때]    <% } %> 처럼, [다른쪽 중괄호로 닫는다.]

        - 3. [단순히 딱 떨어진 HTML 코드를 잘라], [파일에 넣고], [한 폴더에 집어넣으면] [어디든 그 코드를 끼워넣을 수 있다.]
                * HTML 코드의 [변수화?]

            <header id="main-header">
            <div id="logo"><a href="/index">Eatwell</a></div>

            ...

            <span></span>
            </button>
            </header>          
            
            * 이러한 header HTML 코드를 잘라, [header.ejs] 에 집어넣고, [include] 라는 폴더를 만들어 집어넣어준다.
            
            ** 우리는 모든 HTML 파일에 이 header가 들어가므로, 
                        [모든 HTML 파일의 header 안에 있는 코드들 대신]
                <head>
            -   <%-  include("include/head") %>
                </head>
                <main>
            -   <%-  include("include/header") %>
            -   <%-  include("include/aside") %>
                </main>
                        처럼 사용하면, [마치 변수에 저장하고 사용하듯, HTML 코드를 사용할 수 있다.]
            
            사용 : 모든 반복되는 구문에 대하여 사용 
                        EX) header, aside, footer 등 [모든 페이지가 같은 코드이름]

[15. 동적 라우트를 연결]

    - [1. 동적 라우트를 만든다. [/:id] , [req.params.id;]       ]
        app.get("/restaurants/:id" ,function(req,res){
            const retaurantId = req.params.id;
            res.render("restaurants-detail", {rid : retaurantId})

        })
-              * URL(특정 id)을 통해, [URL에 의한 아이디값을 받아온다].    
              * ["/restaurants/:id"], [req.params.id;]

                  
    - [2. recommned에서 form을 받아와 저장할때 고유의 id값을 만들어서 같이 저장하도록 한다.]

        app.post("/recommend", function(req,res){
            const restaurant = req.body;
            restaurant.id = uuid.v4();
        )}

        -   를 통해, 고유한 ID 값도 함께 저장되도록 만든다.
            * uuid를 설치하고, require() 로 불러오는것도 잊지 말것.

    ==>> IF CHECK에서 , [1번과 2번을 비교하여 Id에 맞는 객체의 값을 가져올것이다.]


    - [3. restaurants-detail.ejs 파일에서, 불러와질 각 값을 ejs구문으로 작성한다 (나의 키는 title 로 정했다.)].


    - [4. for 문과 if문을 통하여], 
-       1) [URL을 통해 받아온 id 값] 
            ==>>  [json파일에서 온], [id값으로 만들어진 li]의 [고정된 앵커태그 주소에 의해 나온 URL의 값]을 받아 [만든 값]
            * restaurant-detail 에 접근하기 위한 버튼의 앵커태그는 [만들어질때, 고정됨을 명심하자]
            
-       2) [JSON 파일 자체에 있는 [모든 객체들] 을 검사하여 각 ID값을 뽑아낸 값중 하나!]
-       위의 1) 과 2) 가 동일하다는 조건을 가진다면 [그 조건을 만족하는 JSON 파일의 객체를 하나 뽑아, 거기서 나온 값을 사용]

        app.get("/restaurants/:id" ,function(req,res){
            const retaurantId = req.params.id;
            
            const filePath = path.join(__dirname,"data","restaurant.json")
            const fileText = fs.readFileSync(filePath)
            const storedRestaurants = JSON.parse(fileText)

            for (const restaurant of storedRestaurants){
                if(restaurant.id == retaurantId){
                    return res.render("restaurants-detail", {title : restaurant})
                }
            }
        })

        // id가 같은 것을 찾았으면 [루프를 멈추기 위해 return 을 사용]
        // 같은 id를 찾았다면, [어떤 한 배열의 객체가 선택된 것이고,] [storedRestaurants 안의 값들이 restaurant로 받아와지고 ]
        // "restaurants-detail" 에서, [title 이라는 ejs 구문을 가진 코드를], [for 루프의 restaurant, 즉, storedRestaurants로 바꿔준다.]


    * 처리순서 : 1. [HTML의 restaurant] 에 있는 [버튼]이 href = "restaurants/id" 이것이므로, domain/restaurants/id 라는 URL에 접근한다.
                                                                * 최종적으로 [id] 조차 [동적으로 만들것]이다.
                    최종 : href = "restaurants/ <%= restaurant.id %>"

                2. URL에 접근하면, get에 의해 ["restaurants/:id"] 에 접속했으므로,
                    [req.params.id]에 의해, id값이 생성되고, [render에 의해] [restaurant-datail.ejs 를 불러온다.]

                3. [restaurant-datail 페이지]는 [restaurant.json] 의 값을 ejs로 받아왔는데
                    [추가적으로], [params.id 에 의한 값도 받아온다.]
                    * 이때, HTML의 CSS와 JavaScript 파일의 경로가, 상대경로라면, 오류가난다. [앞에 / 를 붙여서 절대경로로 만들어주자]

                4. [이제, json 파일에 push 할때, [고유한 아이디 값을 지정하며, 저장한다.]]
                    * 랜덤함수로, id를 정해주는 패키기 [uuid] 패키지를 설치한다. npm install uuid

            -   5. 최종
                    [restaurant.json]의 모든 데이터를 불러와서 
                    [for - of 를 통해, 또한 IF 를 통해 [모든 배열안의 객체안의 id값]을 [URL에 의해 받아온 ID 값과 비교]]
                        * IF문의 CHECK는 
                            [URL에 입력되어, ID값으로 받아와진 값] === [.JSON 에 입력된 ID 값]
                            이라는 조건이 들어가야한다.
                    [그 값으로 각각의 요소를 채운다.]                