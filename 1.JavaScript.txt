[1. VAR과 LET의 차이점]

    1. [VAR]는 언제든 [전역변수]로 사용된다.
        IF 안에 있던, FUNCTION 안에 있던, 어디던 다 적용된다.
        [LET]은 [전역변수로 사용되지 않는다.]

        [LET]은 [블럭 스코프] 로 사용된다.  : 블럭안에서만 사용되는

    2. [VAR]는 [언제든 다시 재할당 해도 오류가 나지 않는다.]
        var name = "ms"
        var name = "js"
         ==>> 두번 변수를 지정했지만, 오류는 나지 않는다.

    let hobbies = "sprots"
    if(hobbies === "sprots"){
        var ms = "wow"
    }
    console.log(ms)

==>> "wow" 가 나온다.
==>> 만약 let이라면, 내부에서 정의된 변수는 밖으로 나오지 않는다.
==>> [LET 은 명확한 의도를 가지고, 함수나, IF문 안에 LET으로 정의될 경우, 그 안에서만 사용할 지역변수임을 명시하는 것이다.]
==>> [ VAR는 그런 의도를 분별하여 표현할 수 없다. 더군다나, 재할당이 멋대로 되기때문에, 코드중복이 언제든 발생할 수 있다.]


[2. Hoisting 에 대한 이해]
    : Hoisting 이란 [브라우저가 코드를 읽을때, 은밀하게 수행되는 한 동작으로]
        [정의된 모든 변수들을 코드 앞줄로 끌고와서 미리 읽는 것을 말한다.]

    ex) console.log(ms)
        var ms = "msms"

        ==>> undifined

        console.log(js)
        let js = "jsjs"
        
        ==>> 초기화 [오류]

    ==>> var는 브라우저가 호이스팅을 할때, undifined 이라는 초기값을 할당하고, 호이스팅을 하고
    ==>> let은 브라우저가 호이스팅을 할때, 아무런 값 없이, 호이스팅을 하기 때문이다. [그래서 초기화 오류를 나타낸다.]
    ==>> 이는 결국 코드를 순서대로 쓰지 않았을 경우, 이해하기 힘든 코드가 되므로, 그것을 방지하기 위함이다.

    ==>> var는 이것들을 전부 무시하고 사용가능하기에, 코드가 꼬이고 복잡해질 수 있다.


[3. JavaScript는 어떤 형태로 작동하는가.]
    1) 코드작성
    2) HTML에 임포트 [스크립트를 감지하며]
    3) 브라우저가 HTML을 읽음
    4) 브라우저가 HTML의 인라인스크립트를 실행

    4-1) 브라우저의 [코드분석(parsing)]과 [실행]
        1] 코드분석은 브라우저가 js를 읽고, 로딩을 하는 작업
        2] 실행은 실제로 코드가 읽히고 작동하는 작업 [이때 JavaScript 엔진] 을 이용
            [JavaScript 엔진]은 브라우저별로 다른 종류를 사용한다. [구글의 V8, 파이어폭스의 spider monkey 등...]
            [엔진]은 [두가지 부분으로 나뉜다.]
                *코드의 역할은 [머신]에 [코드]를 [컴파일] 한 후, [운영체제]에 전달하는것
            1] 인터프리터   : 코드를 읽고 간단한 [바이트코드로 변환]하여 [스크립트를 실행] [한줄한줄] + [바이트코드를 컴파일러로 전달] - 느림
            2] 컴파일러(JiT): [JS코드를] [머신코드]로 변환하는 것이 [컴파일러의 역할]

            -] 정리하자면, [인터프리터]는 [스크립트를 실행함과 동시에] [바이트코드로 변환]하여, [컴파일러에게 전달!]
                            [인터프리터]가 스크립트를 실행하는 동안 [ 컴파일러는 스크립트를 머신코드로 컴파일]  ==> 동시에 진행

                            [컴파일러에서 변환된 머신코드는] [컴퓨터에 전달되어 실행단계로 들어감] - 매우매우빠름

            +] [브라우저엔진의 추가적인 기능]
                : [API] 와 같은 빌트인 기능을 사용가능하게한다.
    

[4. 코드는 어떻게 실행되는가.]
    1) Heap(힙) : [장기데이터]로 [시스템 메모리 데이터]를 저장한다. - 브라우저가 실행
                : 즉, [프로그램 내에서 다루는 데이터가 저장됨]

    2) stack(스택) : [코드를 실행할때 사용되는 단기메모리] - 브라우저가 스택으로 푸쉬
                  : 즉, [어떤 함수에 어떤 메모리가 할당되는가 를 다루는 것]

    3) event loop(이벤트루프) : 힙, 스택 과는 다르게 [브라우저 엔진]이 아니라 [브라우저]자체가 가지고 있는 것.
                                예시로, 이벤트리스너가 있고, 리스너가 트리거되면 브라우저가 언제발생했는지 알 수 있게하고, 해당정보를 스크립트로 푸시
                                    스크립트를 방해하지 않고, call stack이 빈 상태로 변하면, 순서에 맞게 실행되도록 제어... [나중에다시]
                                    [비동기코드]
        
    -) 코드가 실행되면
        1.HEAP에 장기메모리가 저장되고
        2.코드를 읽어감에 따라, [STACK에 차례대로 하나씩 함수들이 읽힌다.] 
        3. STACK은 가장 처음으로 [익명함수(스크립트 그 자체)]를 시작으로, [계속해서 읽히는 함수가 들어간다.]
            물론, 더이상 쓸모없어진 함수는 STACK에서 [방출되고], 실행되고 있는 함수만 STACK에 저장된다.


[5. 자바스크립트는 단일 스레드이다]
    : 자바스크립트는 한번에 하나의 작업만 할 수 있다. ==> 함수의 실행 순서를 보장한다.

[6. 자바스크립트의 값 의 타입 2가지]
    1] 원시 값 : string, Number, Booleans, null ...
        간단한 값으로, [대부분 스택에 저장]된다. 쉽게 바꾸고, 파기하고 가능하다.
        [원시값을 저장할때는 값 그 자체를 저장한다.]

    2] 참조 값 : [일반적인 객체 들을 말한다.]
        let name = "msms"
            name.length ==> 4
            처럼 String(원시값)도 사용하고 나면 (.)을 사용하여 [프로퍼티]에 접근할 수 있어서
                 [원시값도 객체 아니냐] 할 수 있지만 그저 [사용할 때 잠시,변환되어 있었을 뿐 객체가 아니다]
                [실제 객체는 더 커다란 덩어리로 [큰 메모리 차지를 요구한다.]] 
            [ 큰 메모리의 차지를 요구한 다는 것은]
            [ 브라우저가 직접적으로 값을 저장하기 힘들다는 말이고]
            [ 브라우저는 직접 저장 대신 [값의 주소를 저장하는 것으로 대체한다.]]

    ** 1.practice.js , [6]참조

[6-1. 참조값을 주소가 아닌 실제 데이터로 복사하려면? 전개연산자(스프레드 연산자) [...] 을 이용한다.]    

    ** 1.practice.js , [6]참조

[7. 가비지 컬렉터와 메모리 누수의 방지]

// 1
function showText(){
    let value = textInput.value;
    console.log(value || "nope")
}

function addListenerF(){
   clickBtn.addEventListener("click",showText)
}
 
addListener.addEventListener("click",addListenerF)

// 2

function addListenerF(){
   clickBtn.addEventListener("click",function(){
    let value = textInput.value;
    console.log(value || "nope")
   })
}

addListener.addEventListener("click",addListenerF)

==> 둘의 차이점
    1 : function 을 미리 정의하고 실행
    2 : 누를때, function을 만들어 실행

==> 1 : 자바스크립트는 메모리가 넘치는 것을 방지하기 위해, [같은 함수를 재실행 할 경우 [기존 함수에서 새 함수로 대체된다.]]
         그러므로 정상적으로 작동한다.
    2 : 이 코드는 누를때마다, [새로운 함수가 계속 생성된다.] - [함수의 이름이 없기 때문에]
            [ 누를때마다 새로운 리스너가 생기고, 한번에 여러개의 값이 튀어나온다. ]
        - 아주아주 안좋은 코드이자, 하면 안되는 일 [의도하지 않았따면]


                            