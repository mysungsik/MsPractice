[1.     1.app.js]   


[2.     2.connectHTML.js]

    1. [express의 사용]
        - npm init
        - npm install express
    2. 미들웨어 [ app.use(express.static("정적파일폴더"))       ] 
                    : node로 불러온 html의 CSS, javaScript 파일을 연결
                [ app.use(express.urlencoded({extended: false}))           ]
                    : 받아온 텍스트데이터를 자동으로 자바스크립트 코드로
    3. get과 post의 사용
    4. 양식 재 제출을 방지하는 [    res.redirect()  ]
    5. fs와 path 패키지
    6. get 과 post 라우터를 동시에 한 페이지에서
    7. 받아온 파일의 저장 
        - json파일에서 빈 배열 만들기
        - 데이터 받아올 때, 전체 다 받아오기        res.body
        -               , name 별로 따로 받아오기  res.body.name
    8. 자동으로 서버를 재시작해주는 [ nodemon 의 사용 ]
        - npm init
        - npm install nodemon
        - package.json 파일의  "scripts" 에서 
            "start" = "nodemon 2.connectHTML.js"
        - npm start 로 서버시작
    9. [템플릿의 사용] = 진정한 [동적인 웹사이트]
        - 템플릿 엔진의 사용이유
        - 템플릿엔진 ejs의 사용
        - npm install ejs
        - app.set() 의 사용 [ express의 세팅창 ]
        - HTML파일의 확장자를 전부 .ejs 로 변경
        - res.render() 의 사용
        - HTML (=EJS) 에  <%= EJS태그 %> 로 특별한 탬플릿구문을 사용 
        - res.render("파일이름", { EJS태그 : 값 } )
        - 동적인 HTML값의 사용
        - <%=   %> 의 사용 
            [ 단일값 ]
        - HTML 태그 잘라내어, 파일로 저장, 부분부분 붙여넣기
        - <%- include("폴더이름/파일이름")   %> 
            [ HTML태그 붙이기]
        - HTML 안에서 Javascript 구문 사용하기
        - <%    %> 의 사용 
            [ if, for 같은 구문들]

[3. dynamicRoute]

    1. 동적인 route의 id를 사용
    2. 오류해결을 위해, [CSS link], [JavaScripts src]의 경로를 [절대경로로] * [앞에 / 가 있는]
    3. uuid 패키지 의 설치 및 사용
        const uuid = require("uuid") 
        * uuid.v4()
    4. 동적 route 주소로 접근하는 get("domain/:id")
    5. 동적 URL 주소 ID를 받아오는 [req.params.id]    // 4,5번의 id(단어는 마음대로 정하는것)은 동일한 것이다.
    6. 두가지 이상의 값을 받는 렌더링 // res.render("domain"{a : ms , b : js})
    7. .json 배열을 비교할때, [for-of 문]을 사용하여 비교하기 + [return 으로 멈추기]

    8. 처리되지 않는 모든 요청 [ex) 철자가 틀린 웹페이지 http://restaurant (s가 빠짐)]
        에 대하여 [404 not found page 불러오기] - 404.ejs 페이지 - [page not found]
        [ 미들웨어 사용]
    9. [표준화된 오류 페이지] - 500.ejs 페이지 [서버에 문제가 생김]

    10. 상태코드 추가한 후, render 하기도  
            res.status().render()

    11. [다른 폴더에, 다른 파일을 만들어!! ] [코드를 쪼개 함수를 만들어, 중복되는 코드 줄이기]
    12. [다른 폴더에, 다른 파일을 만들어] [ 라우터들을 쪼개 넣어] [라우터를 깔끔하게 관리하기(get, post 등)]
        ==>> [리팩토링]이라고 부른다.
        유의할점:
            1) 내 파일을 [내 다른파일에 require 하기]
            2) 각 파일마다 필요한 패키지는 require 해서 사용하기 [ fs, path 등의 패키지를 쓰는 파일은 각각 전부 해주어야함]
            3) [쪼갠 코드를 모아놓은 파일에는] [module.exports ={}] 로, 노출하고자 하는 함수를 표기하기 [다른일에서 쓸 키 : 함수이름] 
                    * 단순히 함수이름만 사용한다 () 없이
            4) path.join(__dirname,) 을 사용할때, 완전히 다른폴더로 이동하려면 , [".."] 으로 상위폴더로 올라가는 값을 넣어서 위치를 이동해야한다.

    13. [오류코드 만들고, 오류페이지 만들어서 처리하기  [ res.status().render()]        ]

    14. [쿼리 매개변수로, [동적으로 [오름차순, 내림차순으로 바뀌는 정렬버튼 만들기]]]





