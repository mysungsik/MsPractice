[1.     1.app.js]   


[2.     2.connectHTML.js]

    1. [express의 사용]
        - npm init
        - npm install express
    2. 미들웨어 [ app.use(express.static("정적파일폴더"))       ] 
                    : node로 불러온 html의 CSS, javaScript 파일을 연결
                [ app.use(express.urlencoded({extended: false}))           ]
                    : 받아온 텍스트데이터를 자동으로 자바스크립트 코드로
    3. get과 post의 사용
    4. 양식 재 제출을 방지하는 [    res.redirect()  ]
    5. fs와 path 패키지
    6. get 과 post 라우터를 동시에 한 페이지에서
    7. 받아온 파일의 저장 
        - json파일에서 빈 배열 만들기
        - 데이터 받아올 때, 전체 다 받아오기        res.body
        -               , name 별로 따로 받아오기  res.body.name
    8. 자동으로 서버를 재시작해주는 [ nodemon 의 사용 ]
        - npm init
        - npm install nodemon
        - package.json 파일의  "scripts" 에서 
            "start" = "nodemon 2.connectHTML.js"
        - npm start 로 서버시작
    9. [템플릿의 사용] = 진정한 [동적인 웹사이트]
        - 템플릿 엔진의 사용이유
        - 템플릿엔진 ejs의 사용
        - npm install ejs
        - app.set() 의 사용 [ express의 세팅창 ]
        - HTML파일의 확장자를 전부 .ejs 로 변경
        - res.render() 의 사용
        - HTML (=EJS) 에  <%= EJS태그 %> 로 특별한 탬플릿구문을 사용 
        - res.render("파일이름", { EJS태그 : 값 } )
        - 동적인 HTML값의 사용
        - <%=   %> 의 사용 
            [ 단일값 ]
        - HTML 태그 잘라내어, 파일로 저장, 부분부분 붙여넣기
        - <%- include("폴더이름/파일이름")   %> 
            [ HTML태그 붙이기]
        - HTML 안에서 Javascript 구문 사용하기
        - <%    %> 의 사용 
            [ if, for 같은 구문들]

[3. dynamicRoute]

    1. 동적인 route의 id를 사용
    
    2. 오류해결을 위해, [CSS link], [JavaScripts src]의 경로를 [절대경로로] * [앞에 / 가 있는]

    3. [const uuid = require("uuid")] 
        uuid 패키지 의 설치 및 사용
        [uuid.v4()]
        랜덤배열문자열 만들기

    4. [get("domain/:id")] 동적 route 주소로 접근하는 

    5. [req.params.id] 동적 URL 주소 ID를 받아오는     // 4,5번의 id(단어는 마음대로 정하는것)은 동일한 것이다.

    6. 두가지 이상의 값을 받는 렌더링 // res.render("domain"{a : ms , b : js})

    7. [.json 배열을 비교할때], [for-of 문]을 사용하여 비교하기 + [return 으로 멈추기]

    8. app.use(function(req,res){
            res.render("404")
        })
        처리되지 않는 모든 요청 [ex) 철자가 틀린 웹페이지 http://restaurant (s가 빠짐)]
        에 대하여 [404 not found page 불러오기] - 404.ejs 페이지 - [page not found]
        [ 미들웨어 사용]

    9. app.use(function(error,req,res,next){
            res.render("500")
        })
        [표준화된 오류 페이지] - 500.ejs 페이지 [json파일 등, 파일의 문제로 인해, 서버에 문제가 생김]  

    10. 상태코드 추가한 후, render 하기도  
            res.status().render()

    11. [다른 폴더에, 다른 파일을 만들어] [ 코드를 쪼개 함수를 만들어, 중복되는 코드 줄이기]
    
        1. util 폴더에, .js 만들고 [function 으로 코드를 묶어서]
        2. 각각 필요한 패키지는 require 시키고
        3. module.exports = {쓸키:함수이름} 으로 내보내기

        1. const resData = require(./폴더이름/파일이름) 으로 받기
        2.  변수 = redData.함수이름() 으로 [변수에 저장해서 사용하거나]
            resData.함수이름() 으로 [즉발적으로 사용]


    12. [다른 폴더에, 다른 파일을 만들어] [ 라우터들을 쪼개 넣어] [라우터를 깔끔하게 관리하기(get, post 등)]
        ==>> [리팩토링]이라고 부른다.

    12-1.   const express = require("express")
    [준비]  const route = express.Router();
            module.exports = route

    12-2.   const data = require(./폴더/파일이름)
    [사용]  app.use("/",data)

        유의할점:
            1) 내 파일을 [내 다른파일에 require 하기]
            2) 각 파일마다 필요한 패키지는 require 해서 사용하기 [ fs, path 등의 패키지를 쓰는 파일은 각각 전부 해주어야함]
            3) [쪼갠 코드를 모아놓은 파일에는] [module.exports ={}] 로, 노출하고자 하는 함수를 표기하기 [다른일에서 쓸 키 : 함수이름] 
                    * 단순히 함수이름만 사용한다 () 없이
            4) path.join(__dirname,) 을 사용할때, 완전히 다른폴더로 이동하려면 , [".."] 으로 상위폴더로 올라가는 값을 넣어서 위치를 이동해야한다.

    13. [res.status().render()] 오류코드 만들고, 오류페이지 만들어서 처리하기 

    14. [쿼리 매개변수로, [동적으로 [오름차순, 내림차순으로 바뀌는 정렬버튼 만들기]]]

    15. [req.query.name] 쿼리 매개변수를 받아오는 코드

    16. [배열.sort(function(A,B){ 
            if(A.객체키 > B.객체키){
                return 1
            }
        })]
        => 배열 정열시키는 함수 [배열.sort()]



    [결론]
    1. 동적라우트 ==>  /:id 

        사용이유 => 사용자가 단일제품에 대해, 상세페이지를 불러올때
                    [수천만개가 넘는 모든 단일제품에대해, 상세페이지 라우트를 달 수 없으니, 동적으로 생성되어, 알아서 작동되는 라우트 필요]

    2. 오류코드 ==> app.use(function(req,res){}) , res.status.render() , app.use(function(error,req,res,next){})

        사용이유 => 사용자가 [잘못된 페이지주소, 혹은 내부파일을 건드려, 오류가 날 경우]
                    모든 잘못된 주소페이지에 대해, 라우트를 달 수 없으니
                    [특정 라우트 주소를 제외하면], 전부 처리되게 [미들웨어를 활용] 하여 오류 페이지를 만들어 노출시킴
                        *그러므로 반드시, 코드 마지막줄에 적어야함(미리 이걸로 처리되면 안되니)

    3. 리팩토링 ==> module.exports ={ a:a} /  const data =require(./forder/file)  / data.function() / express.Router()
        사용이유 => 코드를 간단하고, 편리하게 관리

    4. 쿼리매개변수 => <form ><input type="hidden" value="asd" name ="name"> // req.query.name // 배열.sort(function(A,B){if...})

        사용이유 -> [ URL에는 아무런 영향이 없지만, query값을 뽑아내, 페이지를 유동적으로 처리할수 있게 함] 
                    [ 리스트의 순서(오더)를 바꾸는데 적합 [정배열,역배열 등]]
                






