[1. sync(동기식) 와 async(비동기식)]

sync : 파일이 읽혀지고 실행될때까지, 코드는 멈추고, 읽는것을 우선시하여, 전부 다 읽혀야 코드가 넘어감
async : 파일이 읽혀지고 실행될때까지, 다음 줄의 코드들은 계속해서 작동함

[차이점]
조건1 [파일을 읽는 도중, 아직 파일이 읽히지 않은채, [파일과 연관된 다음줄의 코드가 먼저실행] ==> 오류발생 ==> 동기식으로 파일부터 전부 읽히고, 넘어가야함]
조건2 [파일을 읽는 도중 다음 코드 줄을 읽어도, [파일과 다음코드줄이 전혀 관계가 없음] ==>> 비동기식으로 해도 전혀 상관 X]

[작동조건]
sync : [알아서 retrun 되므로] [변수에 저장하여 사용]
async : [스스로 return 되지 않음!]


-  [비동기식의 사용] :
        비동기식의 콜백함수는 [2가지의 파라미터를 가진다.]
             - [error, 읽은 파일을 저장할 변수이름]

        function readFileData(){
            let fileData;

            fs.readFile("data.txt", function(error, fileData){
                if(error === true){
                    ...
                }
                console.log("file parsing done!")
                console.log(fileData.toString())
            })
        }
        ==>> [error] 라는 파라미터는 [오류가 발생했을때 값을 가지고]
            [변수 fileData] 는, "data.txt" 읽기가 성공하면 fileData에 데이터를 저장한다.
-       ==>> [중요한점은]
            [비동기식] [콜백함수]의 내부에서 사용된 [fileData]는 [readFile() 이라는 함수 내부에서만 사용가능하다]
            그러므로, fileData 를 [읽어서 사용할 것들은 전부 readFile의 콜백함수 내부에 전부 몰아넣어 사용해야한다.]
-       ==>> [그래서 콜백함수 내부에 console.log(fileData.toString()) 가 들어가있는 것이다.]

* 중요한것 : callback 함수라는 단어의 이해

[2. 비동기작업의 콜백함수의 지옥에서 탈출하기] 
                                ==>> promise , .then() , .catch(function(error){})

    : 수많은 readFile, dataBase의 접근 등으로 [우리는 수많은 콜백함수 안의 콜백함수 안의 콜백함수를 만나게된다.]
    : 코드는 읽기 어려워지고, 복잡해서지고, 오류가 날 확률리 높아진다.

-   [콜백함수지옥]
    fs.readFile("data.txt", function(error, fileData){
        asd.function(asd, function(asd,fgdfh){
            asd.function(asd, function(sdf,sdfd){
                ...
            })
        })
    })
    [코드가 복잡해지고, 읽기 어려워지는 이 콜백함수를 탈출하기 위해] [깔끔하게 정리되는 promise 를 사용할것]


    const fs = require(fs/promise)




    ===>> [promise] 를 통해서, [콜백함수 없이 [구조화되도록] 처리하도록 해본다.]

    [완벽한 장점]
        : 코드를 구조화하기 매우 좋다. [가동성이 매우 좋아진다.]
         Promise chain을 통해, 깔끔하고 보기좋은 코드를 만들 수 있다.
         
    [차이점]
    : [error 처리]
        .catch(function(error){
        })


