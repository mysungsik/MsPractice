[INDEX]==============================================================================================================================

<ES6 에서부터의 차이점>

131. 함수의 구분 (메서드와 일반함수, 화살표함수)

[MAIN]==============================================================================================================================


131. callable, constructor, non-constructor

    callable : 호출할 수 있는 함수 객체                         [내부메서드 call 존재]

    constructor : "인스턴스" 를 생성 할 수 있는, 함수 객체      [내부메서드 construct 존재]
        => "생성자 함수로 호출 가능"


    non-constructor : "인스턴스"를 생성할 수 "없는", 함수 객체
        => "생성자 함수로 호출 불가능"

132. ES6의 함수의 구분 (메서드와 일반함수, 화살표함수)
    : ES6 에 와서, 함수는 명확히 구분되어, 특징을 가진다.


    1) 메서드
        : "메서드 축약표현" 으로 정의된 함수 [함수 선언문 형식]
        : "인스턴스를 생성할 수 없는", non-constructor ==> "생성자 함수 호출 불가"
        
        : "인스턴스를 생성할 수 없으므로", "prototype"을 가질 수 없고, "prototype 으로 상속"이 불가능하다.
        : "자신을 바인딩한 객체 [HomeObject] 내부슬롯"을 가지고 있으므로, "super 키워드" 는 "사용 가능"하다.

                const obj = {

                    foo(){}                 ==> "메서드 축약표현" == 메서드

                    bar : function(){}      ==> "메서드 축약표현 X" != 메서드
                }

        => foo는 "non-constructor" : 생성자 함수로 호출 불가
        
        
                const base = {
                    name:"Lee",
                    sayHi(){
                        return `Hi, ${this.name} `
                    }
                }

                const derived = {
                    __proto__:base         // "__proto__ 를 이용하여, 원하는 부모를 선택하여 super 키워드(상위객체의 필드, 메서드를 받는행위) 사용가능"
                    
                    sayHi(){
                        return `${super.sayHi()}`
                    }
                }

    
    2) 화살표 함수
        : "함수 선언식이아니고", "함수 표현식" 으로으로 정의해야 한다. [cosnt funx = () => {...}]
        : "인스턴스를 생성할 수 없는", non-constructor ==> "생성자 함수 호출 불가"

        : "인스턴스를 생성할 수 없으므로", "prototype"을 가질 수 없고, "prototype 으로 상속"이 불가능하다.
        : "자신을 바인딩한 객체 [HomeObject] 내부슬롯"이 "없으므로", "super 키워드도 사용 불가능"
                        

        
