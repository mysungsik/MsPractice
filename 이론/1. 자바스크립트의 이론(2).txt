[INDEX]==============================================================================================================================

<기본이론>
76. 일급객체?
77. 일급객체인데 어떻게하라고?
78. "자바스크립트"는 "명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍이다!"


[MAIN]==============================================================================================================================

76. 일급객체?

    : 일급객체란 다음 4가지의 조건을 모두 만족하는 객체이다.

            1) 무명의 리터럴로 생성 가능하다. 즉, "런타임에 생성 가능하다"  [무명이 아니라면, 런타임 이전에 생성된다.(호이스팅에 의하여)]
            2) 변수나 자료구조(객체,배열 등)에 저장 할 수 있다.
            3) 함수의 매개변수에 전달할 수 있다.
            4) 함수의 반환값 으로 사용할 수 있다.
            
    => 그러므로 "함수"는 "일급객체이다"

77. 일급객체인데 어떻게하라고?
    
    : 일급객체이므로, "함수" 와 "객체"는 동일하게 사용 할 수 있다.

        추가적으로 "함수" 는 객체와는 달리, "호출도 가능하다"

78. 함수는 "객체"이므로, "프로퍼티" 를 가진다.

    함수의 프로퍼티는" 5가지의 데이터 프로퍼티", "1가지의 접근자 프로퍼티를 가진다".

        * 접근자 프로퍼티는 아직 뭔지 잘 모르겠으니까...

    데이터프로퍼티
        1) arguments : 함수에 들어가는 "arguments 객체"를 반환 (단, 지역변수로, 함수 내에서만 사용가능하다.)
                * 파라미터보다, 부족한 인수나, 넘치는 인수가, 화면에는 표기되지 않지만, arguments 프로퍼티에는 저장된다.
                * arguments 객체는 "배열이 아님을 명심"
                ** arguments 객체는, 매개변수를 확정할 수 없는, "가변 인자 함수" 를 구현할 때 유용하다.

                        function sum() {
                            let res = 0;
                            for (let i = 0; i < arguments.length; i++) {
                            res = res + arguments[i];
                            }
                            return res;
                        }
                        
                        console.log(sum(1, 2, 3));

        2) caller   :  안쓴다 이제

        3) length   : 선언한 매개변수의 개수를 가르킨다.        console.log(sum.length);            // 0

        4) name     : "함수 이름" 을 알려준다.              
                const msFunction = function add(){...}       console.log(msFunction.name)    // add

        5) prototype : "불리언 타입으로" 생성자 함수로 호출 가능한, "constructor 내부메서드를 가지고 있는 함수 만이, true 로 나온다."   ***
                            * constructor 내부메서드를 가지고 있는 함수 : 화살표함수, 무명의 리터럴 함수 를 제외한 함수전부

78. 추가. "오로지 함수 객체 만이", prototype 을 가진다.(상속을 위한) ==  constructor 내부메서드를 가지고 있는 것은 "함수 객체 뿐이다"

79. "자바스크립트"는 "명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 "멀티 패러다임 프로그래밍이다"

80. 다시보는 "객체지향 프로그래밍 한줄 요약"
    : 객체 지향 프로그래밍은, "상태를 나타내는 상대 데이터와, 동작은 나타내는 논리" 를 "하나의 객체처럼 취급" 하여,
        "한가지 역할을 수행하는 객체들"의 집합(조합)으로, "프로그램을 구현하는 프로그래밍" 

81. "상속" 과 "프로토타입"

    : 생성자함수를 만들고, 인스턴스를 생성하였다.
     
        function Circle(radius){
            this.radius = radius;
            this.getDiameter = function(){
                return this.radius *2
            }
        }

        cosnt circle1 = Circle(5)
        const circle2 = Circle(10)
            ...

    "이 인스턴스들은, 전부! getDiameter 라는 메서드를 소유한다." 빵틀에서, 빵을 찍어내듯

    이 행위는, "똑같은 메서드를 무한 복사 하는 것이므로" "메모리에 악영향을 끼친다."

    [그 행위를 막기 위해서는 "상속" 을 한다.]
        : 상속은 객체의 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용하는것이다.
            즉, "복사가 아니라, 거기있는 것을 그냥 쓰는것이다."

82. 상속할 함수를 만드는 방법 [ 생성자함수.prototype.메서드이름 = function(){ ... }]
    : 위의 함수의 메서드를 "상속할 메서드" 를 만든다.
        ==> "생성자함수를 다시불러", "prototype 프로퍼티에 접근"해, "함수를 만든다".

        function Circle(radius) {
            this.radius = radius;
-           Circle.prototype.getDiameter = function () {
            return this.radius * 2;
            };
        }
        
        const circle1 = new Circle(5);
        
        console.log(circle1.getDiameter());

    ==> 이제 이 인스턴스들은, 생성자함수의 메서드를 "복사 하지 않고", "상속 (=공유)" 한다.
        
83. 프로토타입 객체 (prototype) 은 "상속" 을 구현하기 위해 사용된다.
    : 프로로타입 객체에, 접근하는 방법은, " __proto__" 접근차 프로퍼티를 사용하는 것이다.

        * 하지만 "접근자 프로퍼티" 는 "직접적인 접근은 불가능하다."

        어렵다...

84. "상속자(부모)" 를 선택하기, 교체하기! [ getPrototypeOf , setPrototypeOf ]
    :  "자식" 은 내가 "상속 받고자 하는 부모" 를 확인하고, 교체 할 수 있다.

       

        1) 부모 확인 => "프로토타입 취득"   => Object.getPrototypeOf(자식)

            const obj = {}
            const parent = { x : 1 }

            Object.getPrototypeOf(obj)

        2) 부모 교체 => "프로토타입 교체"   => Object.setPrototypeOf(자식, 부모)

            const obj = {};
            const parent = { x: 1 };
            
            Object.setPrototypeOf(obj, parent);
            
            console.log(obj.x);     // x = 1
            
85. ESLint 와 Strict Mode

    : Strict Mode 는, 언어의 문법을 "완벽하게" 지키지 않으면, 오류가 발생한다.
        이는, "잠재적 오류를 미연에 방지" 하는 효과가 있다.

    : ESLint 는 더 나아가, "문법과, 코딩컨벤션" 도, 정의하고 강제할 수 있기 때문에, 상위 호환이라 할 수 있다.

86. Strict Mode 의 사용

    1) 전역의 선두에 use strict; 를 사용    // 권장되지 않음

            use strict;
                
            function ms(){
                ...
            }
    
    2) 함수의 선두에 use strict; 를 사용

            function ms(){
                use strict;
                ...
            }
        
87. Strict Mode 의 기능

    1) 암묵적 전역 방지 : 선언하지 않은 변수를 참조하면 오류

    2) 매개변수 이름의 중복 사용 : function( x, x ) {...} 오류

    3) with 문의 사용   : 잘모르는데 사용하면 오류

    4) 일반함수에서 this 를 사용하면 : undefined 이 나온다.

        * 일반모드에서 이러면 "window" 가 잡힌다.

            function ms() {
                console.log(this);
            }
            
            ms()        // Window { ... } 


88. 자바스크립트 객체의 분류

    1) 표준 빌트인 객체
        : ECMAScript 사양에 정의된 객체로, "자바스크립트 실행환경(브라우저, Nodejs ...)" 와는 "관계 없이" 언제나, 전역에서, 사용가능하다.
            "별도의 선언이 필요 없고, 전역변수처럼 언제나 참조"가 가능하다.

    2) 호스트 객체
        : ECMAScript 사양에 정의되지 않은 객체로, 브라우저나, Nodejs 같은 "자바스크립트 실행환경" 에서 "별도로 제공하는 객체이다"
            "브라우저" 에서는 , "fetch", "DOM", "BOM", "SVG","Canvas" 등... "클라이언트 사이드 Web API 로 제공"
            "Node.js" 에서는, "고유의 API 를 호스트 객체로 제공한다."

    3) 사용자 정의 객체
        : 사용자가 직접 정의한 객체이다.

89. 표준 빌트인 객체
    : 표준 빌트인 객체는, "Object", "String", "Number", ... "Date", "Math", "Array", "Map/Set" ... "Function"...
            등, 40여가지 표준 빌트인 객체를 제공하며

        Math, Reflect, JSON 을 제외한 "모둔 표준 빌트인 객체는" "생성자 함수 객체이다."

            const strObj = new String("Lee")
            console.log(typeof strObj)          // object       ==> 생성자 함수로 호출했으니, 객체가 반환되었다.

            const numObj = new Number(54)
            console.log(typeof numObj)          // object       ==> 이하동문

            const date = new Date();
            console.log(typeof date)            // object       ==> 이하동문

                            ...

90. 굳이! 왜 표준빌트인 객체를 사용하여, string, number 등을 만드는가? 그냥 원시값으로 만들면 되는데?
    : 동작 원리 때문에 그렇다.

        원시값도 객체처럼 사용 할 수 있다.

            const str = "hello"
            console.log(str.toUpperCase())      // HELLO    
            console.log(str.length)             // 5

        이는, 자바스크립트가, 암묵적으로 "원시값을 객체처럼" 생성하고, 프로퍼티와 메서드에 접근해, 호출하고 다시 원시값으로 돌리는 것이다.

        이때, 암묵적으로 사용되고, 접근되는 것이, "표준 빌트인 객체 String()" 이다.

        같은 원시값인, num, boolean 도 마찬가지로 작용된다.

91. 전역객체
    : 런타임 이전, 자바스크립트 엔진에 의해 "어떤 객체보다 먼저 생성되는 특수한 객체이며, 어디에도 속하지 않은 최상위 객체이다."

        "브라우저 환경"에서는 "window" 로 불리우고
        "node 환경"에서는 "global" 이 전역객체를 가르킨다.

    전역객체는, 전역객체 이름을 생략하고, 사용 가능하다

        window.Infinity ==> Infinity
        window.NaN      ==> NaN
        window.console  ==> console

92. 전역객체의 여러가지 프로퍼티

    Infinity    => 무한수를 나타냄
    NaN         => Not A Number
    undefined   => undefined

    isFinite     => 유한수(2,3 ...)면 true,  무한수 (3.142232...), NaN 이면 false   
        isFinite(Math.PI)   => true
        isFinite(3)         => true

        isFinite(Infinity)  => false
        isFinite("hello")   => false

    isNaN       => 숫자가 아닌지 맞는지 확인
        isNaN(NaN)  => true
        isNaN(10)   => false

    parseFloat  => 문자열을 실수로
        parseFloat("3.14")  => 3.14
        parseFloat("hi")    => NaN

    parseInt    => 문자열을 정수로

        parseInt("10.2")    => 10
        parseInt(10.66)     => 10

        parseInt("10", 2)   => 10을 2진수로 해석하여 정수로 반환        => 2
        parseInt("10", 8)   => 10을 8진수로 해석하여 정수로 반환        => 8

    IncodeURI(uri)   => uri를 "어떤 시스템에서도 읽을 수 있는", "아스키 문자 셋" 으로 변환하는 것

    DecodeURI(uri)   => "아스키 문자 셋" 을 다시, "일반적 문자열"로 변환

93. 암묵적 전역
    : 아래 함수를 보자

            function ms(){
                y= 20
            }

            ms()

            console.log(y)  // 20

    "y 는 선언된적이 없다", 어떻게 된것일까?

    "자바스크립트는" 전역, 스코프내 어디에서도 y 를 찾을 수 없어, "y를 전역 객체의 프로퍼티"로 생성한다.    window.y =20

    그렇게 y 가 "암묵적 전역"변수가 된다.

94. 자기 참조 변수 this

    : 자기 참조 변수 this 는, "자신이 속한 객체" 혹은 "자신이 생성할 인스턴스" 를 가르키는 "자기 참조 변수" 를 말한다.

        "this가 가르키는 값" = "this 바인딩" 이라고 한다.

        [1) 일반 함수에서의 this]

            function ms(){
                console.log(this)
            }

            ==> this는 window, 즉, "전역" 을 가르킨다.

        [2) 일반 객체에서의 this]
                
                const circle = {
                    radius : 5,
                    getDiameter(){
                        return 2 * this.radius
                    }
                }

            ==> this 가, 객체 자신을 가르킨다.

        [3) 생성자 함수에서의 this]

                function Circle(radius){
                    this.radius = radius;
                    Circle.prototype.getDiameter = function(){
                        return 2* this.radius                       // 여기의 this 는
                    }
                }

                const circle1 = new Circle(5)   
                console.log(circle.getDiameter())                   // "자신이 생성할 인스턴스, circle1" 을 가르킨 것이다.

            ==> this 가, "자신이 생성할 인스턴스" 를 가르킨다.

        [4) 메서드 의 this]

                var value = 1;

                const obj = {
                    value: 100,
                    ms: function () {
                        console.log(this.value);
                    },
                };
                
                obj.ms();               // 100

            => 결국 일반객체와 다름없이, "호출한" "객체 자신"을 가르킨다.

                ** 생성한 이 아니고 "호출한 객체 자신이다". 헷갈리면 안된다.

        [5) 콜백함수 this]

                var value = 1;

                const obj = {
                    value: 100,
                    ms: function () {
                        console.log(this.value);
                        setTimeout(function(){
                            console.log(this.value)         // 콜백함수의 this
                        },100)
                    },

                };
                
                obj.ms();   

            ==> "콜백함수도, 일반함수 취급하기 때문에, "window" 즉,글로벌이 this 에 바인딩된다."
                
        

95. 자기 참조 변수 this 의 Strict Mode 에서의 사용

    : 사실 this 는, "객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수" 이므로,
        일반적으로는, "객체의 메서드 내부" 혹은 "생성자 함수 내부" 에서만 의미가 있다

    그러므로, strict mode 가 적용된 "일반함수의 내부에서 this" 는 사용 불가능하다(가능은 하지만 undefined).

96. 렉시컬 스코프

    : 함수를 "어디에서 호출(호출)" 하였는가 보다는, 함수를 "어디에서 선언(정의)" 하엿느냐가, "스코프 결정"에 영향을 주는 스코프 결정 방법

            var x = 1; // global

            function first() {
                var x = 10;
                second();
            }
            
            function second() {
                console.log(x);
            }
            
            first();        // 1
            second();       // 1

        => 어? 뭐지?
            second의 console.log(x) 에는 "선언된 시점의 x 즉, x = 1" 이 들어간다.
            "first" 에서 "second" 를 "호출 하던말던", 
            어차피 second는 x = 1 이 적용된 스코프( global ) 에서 "선언 되었기 때문에", 스코프는 "전역의 x" 즉, 1 이 되는것이다. 


    반) "동적 스코프"
        : 호출시점이 함수에 영향을 준다.


96. [추가] "스코프 체인"

    : 스코프 체인은, 자바스크립트가, "변수를 검색하는 방법"
       "하위 스코프부터, 상위로 올라면서 찾는다."

97. 소스코드의 타입
        * 소스 코드 : 프로그램을 사람이 읽을 수 있는 프로그램 엄어로 기술한 텍스트   == "코드"

        1) 전역 코드    : 전역에 존재하는 소스코드. "함수나 클래스 등의 내부코드는 포함되지 않는다."
                예) 함수 선언문(함수 표현식 아님!), 변수 선언문

        2) 함수 코드    : 함수 내에 존재하는 소스코드. "함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다."

        3) eval 코드    : 빌트인 전역함수 eval 함수에 인수로 전달되어 실행되는 소스코드

        4) 모듈 코드    : 모듈 내부에 존재하는 소스코드, "모듈 내부의 함수나, 클래스 등의 내부코드는 포함되지 않는다."


98. 실행 컨텍스트의 역할

    : "실행 컨텍스트" 는 코드를 실행하는데 "필요한 환경을 제공"한다. 또한 "그 실행 결과를 관리"한다.

    =>  "식별자를 등록, 관리 하는 스코프 구현", 
        "코드 실행 순서 관리 구현"
        "모든 코드는 실행 컨텍스트를 통해 실행되고  관리된다."
    
    1) 전역 코드 평가

        :   "선언문" (함수 선언문 function add(){...} , 변수 선언문 const x = "x") 이 실행
                => "전역 함수", "전역 변수" 가 "전역 스코프에 등록"
            
    2) 전역 코드 실행

        : 전역 코드 평가가 끝나면, 런타임이 시작되어, 전역코드가 순차적으로 실행
            "전역 변수에 값이 할당되고, 함수가 호출"된다.

    3) 함수 코드 평가

        : 함수 호출에 의해, "전역코드 실행을 일시 중단" 하고, "함수의 코드를 실행하기 위한 평가에 들어간다."
            => "지역변수" 가 "지역 스코프에 등록"

    4) 함수 코드 실행단계
        
        : 함수코드 실행
            => 함수 호출이 종료되면,다시 전역 코드 실행 시작

        <예시>
            const x = 1;

            function1(){
                function2(){
                    function3(){
                        ...
                    }
                }

            }

        1) [전역 코드 평가]
            const x 를 (등록), function1 을 (등록)

        2) [전역 코드 실행]
            const x 에 "값을 참조", function1 "실행시작"

        3) 실행중 function2 를 만나, [함수 코드 평가 시작], [함수 코드 실행]
        
        4) 실행중 function3 를 만나, [함수 코드 평가 시작], [함수 코드 실행]

        5) function3 종료

        6) function2 종료

        7) function1 종료

        8) 전역 코드 종료

99. "실행 컨텍스트", "클로저", 대하여...!  책으로는 이해를 못하겠네 증말 이게 무슨소리야 인터넷검색 ㄱㄱ