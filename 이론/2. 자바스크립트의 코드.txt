0. 단항연상자의 "선할당 후증가", "선증가 후할당"

    ++ , -- => 단항연산자

    <선할당 후증가>
        let x = 1;
        let Xresult = x++;

        console.log(Xresult, x);    // 1,2

    <선증가 후할당>
        let y = 1;
        let Yresult = ++y;

        console.log(Yresult, x);    // 2,2

1. 연산자의 타입변경

    let num = "3"       => console.log(+num) // 3
    let bool = true     => console.log(+bool) // 1


2. 할당 연산자

    "+=, -=, *=  등이 존재"

        =>
            x += 5

            x = x + 5

3. 삼항 조건 연산자
    : if else 와 달리 "값으로 표현 가능한" "표현식" 이다 ***

        let result = score >= 60 ? "pass" : "fail"

        ==> 
            
            if(score >60){
                return result="pass"
            }else{
                return result="fail"
            }

4. typeof 연산자
    :  데이터 타입을 반환

        typeof 1            // "number"
        typeof true         //  "boolean"
        typeof "hi"         // "string"
        typeof undefined    // "undefined"
        typeof null         // "object"

5. 지수 연산자
    : x제곱을 만들어준다.

        2 ** 2  // 4
        2 ** 3   // 8
        ...

        (-5) ** 2 // 25

        [할당 연산자로도 사용 가능]
            let x = 3
            x **= 5

            console.log(x)  // 243

6. switch 조건문
    : if else 와 달리 "참 거짓" 보다는 "값" 으로 판단하는 "조건문"

        switch(){
            case x : [실행문]
                break;
            case y : [실행문]
                break;
            ...
            default : [실행문]
        }

            * break 가 필수적이며, "default" 문에는 필요없다. "default" 에 다다르면 "자동으로 switch 문을 빠져나가기 때문이다."
            
        
    <사용>
        if-else 로는 "조건이 너무 많아서 가독성이 떨어질때" 어쩔수 없이!

7. while 반복문
    : for 을 사용하기에 적합하지 않은, "반복횟수가 불명확한 조건문에 주로 사용"
        결과가 "참"이면 "다시 반복"한다.
        결과가 "거짓"이면 "코드는 실행되지 않고" 자동으로 빠져나온다.


        let x=1;

        while( x<4 ){
            console.log(x)
            x++
        }
    
8. do ... while 반복문
    : 먼저 한번 실행하고, 조건을 적용한다. => "반드시 한번은 실행된다."

        let x =1;

        do{
            console.log(x)
            x++
        }while( x < 4)

9. 특정 글자 위치 찾기 with break 문
    : break 문은 "반복문" 을 탈출시킨다.
        
        let msString = "heeello";
        let search = "l";
        let index;

        for (let i = 0; i < msString.length; i++) {
            if (msString[i] === search) {
                index = i;
                break;
            }
        }
        console.log(index);

10. 특정 글자 개수 알기 with continue 문
    : Continue 가 실행되면, "그 실행코드는 실행되지 않고 넘어간다."

        let msString = "helelllo";
        let search = "l";
        let index = 0;
        
        for (let i = 0; i < msString.length; i++) {
            if (msString[i] !== search) continue;           // 조건에 부합하지 않으면, 넘어간다.
            index++;                                        // 부합하면, 카운트를 올린다.
        }
        console.log(index);                                 // 4
    
11. 명시적 타입 변환(= 타입 캐스팅)
    : 의도적인 타입의 변화

        <문자>
            let x = 3
            let str = x.toString()  // "3" 

            String(3)   // "3"

        <숫자>

            Number(3)       // 3
            Number(true)    // 1

            parseInt("3")   // 3

            +"3"            // 3
            +true           // 1

        <불리언>

            Boolean("x")    // true
            Boolean("")     // false

            Boolean([])     // true
            Boolean({})     // true

               ==> 객체와, 배열은, "비어있어도 true"    **  [가장 헷갈리는 부분이니 조건식 만들때 조심]

12. 암묵적 타입 변환
    : 코드의 문맥을 고려해 "자동적으로 변환되는 것"
    
        let x = 3 
        console.log(x+"hi")     // "3hi"

        ==> num 이 강제로 str 이 된다.

13. string 으로 암묵적 타입 변환

    x + ""      // "x"
    1 + ""      // "1"
    true + ""   // "true"
        ...

14. number 으로 암묵적 타입 변환

    1 - "1"     // 0
    1 * "10"    // 10
    1 / "one"   // NaN      => 실행 불가시 숫자타입이 아님을 나타내는 NaN

    <빈 문자열, 빈 배열, false 는 0>        ==> 조건식을 만족하는 것을 나타내기 적합하다.
        +""         // 0
        +[]         // 0
        +null       // 0
        +false      // 0

    <찬 문자열, 찬 배열 은 NaN >
        +"as"         // NaN
        +[as,as]      // NaN

15. 논리연산자를 이용한, 단축 평가  ***

    1. && 를 이용할때, 둘 다 참이면, "마지막 true 값"을 반환한다.

        "Cat" && "Dog"      // "Dog"
        "Dog" && "Cat"      // "Cat"

    2. || 를 이용할때, "가장 첫번째 참인 값"이 반환된다.

        "Cat" || "Dog"      // "Cat"
        "Dog" || "Cat"      // "Dog"

    ==> "삼항 연산자" 와 더불어 "아주 많이 쓰이는 조건문이다."

        let done = true
        let message = ""

        <조건문>
            if (done){
                message = "완료"
            }
        < && 단축평가>
            message = done && "완료"

        < 삼항 연산자 >
            
            done ? (message = "완료") : (message = "미완료");

            message = done ? "완료" : "미완료"

16. 객체 리터럴 : 프로퍼티의 접근, 삭제, 생성

    <객체 리터럴>

        let prefix = "pre"
        let i = 0

        const person = {
            name: "와우",
            sayHello: function () {
                console.log(`say ${this.name}`);
            },
        };
        
        person.sayHello();

    <메서드 축약>

        const person = {
            name: "와우",
            sayHello() {
                console.log(`say ${this.name}`);
            },
        };


    <접근>

        person.name
        person.["name"]     ** 반드시 "" 안에 넣은 "string" 형태로 적을 것

    <생성>

        person.age = 3
        person.[prefix + "-" + ++i] = i
        person.[prefix + "-" + ++i] = i
        person.[prefix + "-" + ++i] = i

        // { prefix-1 : 1, prefix-2 : 2, prefix3 - 3}


    <삭제>

        delete person.age
        